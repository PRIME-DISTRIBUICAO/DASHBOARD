<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Relatório Otimizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .file-input-label { display: block; text-align: left; font-size: 0.875rem; font-weight: 500; color: #cbd5e1; margin-bottom: 0.5rem; }
        .progress-bar-container { background-color: #1e293b; border-radius: 0.5rem; overflow: hidden; }
        .progress-bar { background-color: #14b8a6; height: 100%; transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 flex items-center justify-center min-h-screen">
    <div class="text-center p-8 bg-slate-800 rounded-lg shadow-2xl max-w-lg w-full m-4">
        <h1 class="text-2xl font-bold text-white mb-4">Gerador de Relatório Otimizado</h1>
        <p class="text-slate-400 mb-6">Carregue os arquivos para gerar um dashboard offline. O processamento agora ocorre em segundo plano, sem travar a interface.</p>
        
        <div class="space-y-4 mb-6">
            <div>
                <label for="sales-file-input" class="file-input-label">1. Arquivo de Vendas (Mês Atual)</label>
                <input type="file" id="sales-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="clients-file-input" class="file-input-label">2. Cadastro de Clientes</label>
                <input type="file" id="clients-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="products-file-input" class="file-input-label">3. Cadastro de Produtos</label>
                <input type="file" id="products-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="history-file-input" class="file-input-label">4. Histórico de Vendas (Trimestre Anterior)</label>
                <input type="file" id="history-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
             </div>
        
        <button id="generate-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg w-full disabled:bg-slate-600" disabled>
            Gerar Relatório
        </button>

        <div id="status-container" class="hidden mt-6 text-sm h-12 flex flex-col justify-center">
            <p id="status-text" class="mb-2"></p>
            <div class="progress-bar-container w-full h-2">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
        </div>

        <div id="download-container" class="hidden mt-6 border-t border-slate-700 pt-6">
            <a id="download-link" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-lg w-full inline-block">
                Baixar Relatório HTML
            </a>
        </div>
    </div>

    <script id="worker-script" type="text/worker-javascript">
        // Importa a biblioteca para ler arquivos XLSX
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');

        // Função para parsear datas (executada dentro do worker)
        function parseDate(dateString) {
            if (!dateString) return null;
            if (dateString instanceof Date) return !isNaN(dateString.getTime()) ? dateString : null;
            if (typeof dateString === 'number') return new Date(Math.round((dateString - 25569) * 86400 * 1000));
            if (typeof dateString !== 'string') return null;
            
            const parts = dateString.split('/');
            if (parts.length === 3) {
                const [day, month, year] = parts;
                if (day.length === 2 && month.length === 2 && year.length === 4) return new Date(`${year}-${month}-${day}T00:00:00`);
            }
            
            const isoDate = new Date(dateString);
            return !isNaN(isoDate.getTime()) ? isoDate : null;
        }
        
        // Função para parsear números no formato brasileiro (executada dentro do worker)
        function parseBrazilianNumber(value) {
            if (typeof value === 'number') return value;
            if (typeof value !== 'string' || !value) return 0;
            const cleaned = String(value).replace(/R\$\s?/g, '').trim();
            const lastComma = cleaned.lastIndexOf(',');
            const lastDot = cleaned.lastIndexOf('.');
            let numberString;
            if (lastComma > lastDot) {
                numberString = cleaned.replace(/\./g, '').replace(',', '.');
            } else if (lastDot > lastComma) {
                numberString = cleaned.replace(/,/g, '');
            } else {
                numberString = cleaned.replace(',', '.');
            }
            const number = parseFloat(numberString);
            return isNaN(number) ? 0 : number;
        }

        // Função para ler o conteúdo de um arquivo (executada dentro do worker)
        const readFile = (file) => {
            return new Promise((resolve, reject) => {
                if (!file) {
                    resolve([]); // Resolve with empty array if no file is provided
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let jsonData;
                        const data = event.target.result;
                        if (file.name.endsWith('.csv')) {
                            let decodedData;
                            try {
                                decodedData = new TextDecoder('utf-8').decode(new Uint8Array(data));
                                if (decodedData.includes(' ')) { 
                                    throw new Error('UTF-8 decoding failed, trying ISO-8859-1');
                                }
                            } catch (e) {
                                decodedData = new TextDecoder('iso-8859-1').decode(new Uint8Array(data));
                            }
                            
                            const lines = decodedData.split(/\r?\n/).filter(line => line.trim() !== '');
                            if (lines.length < 1) {
                                resolve([]);
                                return;
                            };
                            
                            const firstLine = lines[0];
                            const delimiter = firstLine.includes(';') ? ';' : ',';

                            const headers = lines.shift().trim().split(delimiter).map(h => h.replace(/"/g, ''));
                            jsonData = lines.map(line => {
                                const values = line.trim().split(delimiter).map(v => v.replace(/"/g, ''));
                                let row = {};
                                headers.forEach((header, index) => {
                                    row[header.trim()] = values[index] || null;
                                });
                                return row;
                            });
                        } else {
                            const workbook = XLSX.read(new Uint8Array(data), {type: 'array'});
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, cellDates: true });
                        }
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error(`Erro ao ler o arquivo '${file.name}'.`));
                reader.readAsArrayBuffer(file);
            });
        };

        // Função principal de processamento de dados de vendas (executada dentro do worker)
        const processSalesData = (rawData, clientMap, productMasterMap) => {
            return rawData.map(rawRow => {
                const clientInfo = clientMap.get(String(rawRow['CODCLI'])) || {};
                let vendorName = String(rawRow['NOME'] || '');
                let supervisorName = String(rawRow['SUPERV'] || '');
                let codUsur = String(rawRow['CODUSUR'] || '');
                const pedido = String(rawRow['PEDIDO'] || '');
                if (supervisorName.trim().toUpperCase() === 'OSÉAS SANTOS OL') supervisorName = 'OSVALDO NUNES O';
                const nomeClienteParaLogica = (clientInfo.razaoSocial || '').toUpperCase();
                const supervisorUpper = (supervisorName || '').trim().toUpperCase();
                if (supervisorUpper === 'BALCAO' || supervisorUpper === 'BALCÃO') supervisorName = 'BALCAO';
                if (supervisorName === 'BALCAO' && nomeClienteParaLogica.includes('AMERICANAS')) { vendorName = 'AMERICANAS'; codUsur = '1001'; }
                if (pedido.startsWith('120')) { vendorName = 'VD HIAGO'; supervisorName = 'HIAGO ASSUNCAO'; codUsur = '1002'; }
                let dtPed = rawRow['DTPED'];
                const dtSaida = rawRow['DTSAIDA'];
                const parsedDtPed = parseDate(dtPed);
                const parsedDtSaida = parseDate(dtSaida);
                if (parsedDtPed && parsedDtSaida && (parsedDtPed.getFullYear() < parsedDtSaida.getFullYear() || (parsedDtPed.getFullYear() === parsedDtSaida.getFullYear() && parsedDtPed.getMonth() < parsedDtSaida.getMonth()))) {
                    dtPed = dtSaida;
                }
                const productCode = String(rawRow['PRODUTO'] || '');
                const qtdeMaster = productMasterMap.get(productCode) || 1;
                const qtVenda = parseInt(String(rawRow['QTVENDA'] || '0').trim(), 10);
                return {
                    PEDIDO: pedido, NOME: vendorName, SUPERV: supervisorName, PRODUTO: productCode,
                    DESCRICAO: String(rawRow['DESCRICAO'] || ''), FORNECEDOR: String(rawRow['FORNECEDOR'] || ''),
                    OBSERVACAOFOR: String(rawRow['OBSERVACAOFOR'] || '').trim(), CODFOR: String(rawRow['CODFOR'] || ''),
                    CODUSUR: codUsur, CODCLI: String(rawRow['CODCLI'] || ''), CLIENTE_NOME: clientInfo.nomeCliente || 'N/A',
                    CIDADE: clientInfo.cidade || 'N/A', BAIRRO: clientInfo.bairro || 'N/A',
                    QTVENDA: qtVenda, VLVENDA: parseBrazilianNumber(rawRow['VLVENDA']),
                    TOTPESOLIQ: parseBrazilianNumber(rawRow['TOTPESOLIQ']), DTPED: dtPed, DTSAIDA: dtSaida, 
                    POSICAO: String(rawRow['POSICAO'] || ''),
                    FILIAL: String(rawRow['FILIAL'] || ''),
                    ESTOQUECX: parseBrazilianNumber(rawRow['ESTOQUECX']),
                    ESTOQUEUNIT: parseBrazilianNumber(rawRow['ESTOQUEUNIT']),
                    QTVENDA_EMBALAGEM_MASTER: isNaN(qtdeMaster) || qtdeMaster === 0 ? 0 : qtVenda / qtdeMaster
                };
            });
        };

        // Event listener que aguarda mensagens da página principal
        self.onmessage = async (event) => {
            const { salesFile, clientsFile, productsFile, historyFile } = event.data;

            try {
                self.postMessage({ type: 'progress', status: 'Lendo arquivos...', percentage: 10 });
                const [salesDataRaw, clientsDataRaw, productsDataRaw, historyDataRaw] = await Promise.all([
                    readFile(salesFile),
                    readFile(clientsFile),
                    readFile(productsFile),
                    readFile(historyFile)
                ]);
                
                self.postMessage({ type: 'progress', status: 'Extraindo estoque do arquivo de vendas...', percentage: 25 });
                const stockMap05 = new Map();
                const stockMap08 = new Map();

                salesDataRaw.forEach(item => {
                    const productCode = String(item['PRODUTO'] || '').trim();
                    const branch = String(item['FILIAL'] || '').trim();
                    const stockQtyCx = parseBrazilianNumber(item['ESTOQUECX']);

                    if (productCode && branch) {
                        if (branch.includes('5')) {
                            stockMap05.set(productCode, stockQtyCx);
                        } else if (branch.includes('8')) {
                            stockMap08.set(productCode, stockQtyCx);
                        }
                    }
                });

                self.postMessage({ type: 'progress', status: 'Mapeando produtos...', percentage: 30 });
                const productMasterMap = new Map();
                productsDataRaw.forEach(prod => {
                    const productCode = String(prod['Código'] || '');
                    if (!productCode) return;
                    let qtdeMaster = parseInt(prod['Qtde embalagem master(Compra)'], 10);
                    if (isNaN(qtdeMaster) || qtdeMaster <= 0) qtdeMaster = 1;
                    productMasterMap.set(productCode, qtdeMaster);
                });

                const clientRcaOverrides = new Map();
                salesDataRaw.forEach(rawRow => {
                    const pedido = String(rawRow['PEDIDO'] || '');
                    const codCli = String(rawRow['CODCLI'] || '');
                    if(!codCli) return;
                    if (pedido.startsWith('120')) clientRcaOverrides.set(codCli, '1002');
                });

                self.postMessage({ type: 'progress', status: 'Processando clientes...', percentage: 50 });
                const clientMap = new Map();
                clientsDataRaw.forEach(client => {
                    const codCli = String(client['Código'] || '');
                    if (!codCli) return;

                    const rca1 = String(client['RCA 1'] || '');
                    const rca2 = String(client['RCA 2'] || '');
                    const rcas = new Set();
                    if (rca1) rcas.add(rca1);
                    if (rca2) rcas.add(rca2);

                    let registrationDateStr = client['Data e Hora de Cadastro'] || '';
                    if (registrationDateStr.includes(' ')) registrationDateStr = registrationDateStr.split(' ')[0];
                    
                    const clientData = {
                        'Código': codCli,
                        rcas: Array.from(rcas),
                        rca1: rca1, 
                        rca2: rca2, 
                        cidade: String(client['Nome da Cidade'] || 'N/A'),
                        nomeCliente: String(client['Fantasia'] || client['Cliente'] || 'N/A'),
                        bairro: String(client['Bairro'] || 'N/A'),
                        razaoSocial: String(client['Cliente'] || 'N/A'),
                        fantasia: String(client['Fantasia'] || 'N/A'),
                        cnpj_cpf: String(client['CNPJ/CPF'] || 'N/A'),
                        endereco: String(client['Endereço Comercial'] || client['Endereço'] || 'N/A'),
                        numero: String(client['Número'] || 'SN'),
                        cep: String(client['CEP'] || 'N/A'),
                        telefone: String(client['Telefone Comercial'] || 'N/A'),
                        email: String(client['E-mail'] || 'N/A'),
                        ramo: String(client['Descricao'] || 'N/A'),
                        ultimaCompra: client['Data da Última Compra'],
                        dataCadastro: registrationDateStr,
                        bloqueio: String(client['Bloqueio'] || '').trim().toUpperCase(),
                        inscricaoEstadual: String(client['Insc. Est. / Produtor'] || 'N/A')
                    };
                    if (clientRcaOverrides.has(codCli)) clientData.rcas.unshift(clientRcaOverrides.get(codCli));
                    if (clientData.razaoSocial.toUpperCase().includes('AMERICANAS')) clientData.rcas.unshift('1001');
                    clientMap.set(codCli, clientData);
                });

                self.postMessage({ type: 'progress', status: 'Mapeando vendedores...', percentage: 60 });
                const rcaInfoMap = new Map();
                [...salesDataRaw, ...historyDataRaw].forEach(row => {
                    const codusur = String(row['CODUSUR'] || '').trim();
                    if (codusur && !rcaInfoMap.has(codusur)) {
                        rcaInfoMap.set(codusur, {
                            NOME: String(row['NOME'] || ''),
                            SUPERV: String(row['SUPERV'] || '')
                        });
                    }
                });

                self.postMessage({ type: 'progress', status: 'Reatribuindo vendas do trimestre...', percentage: 65 });
                const reattributedHistoryDataRaw = historyDataRaw.map(sale => {
                    const codCli = String(sale['CODCLI'] || '');
                    const clientData = clientMap.get(codCli);
                    const observacaoFor = String(sale['OBSERVACAOFOR'] || '').trim().toUpperCase();

                    if (clientData) {
                        const newSale = { ...sale };
                        let targetRcaCode = null;

                        const currentRca1 = clientData.rca1;
                        const currentRca2 = clientData.rca2;

                        if (currentRca1 && currentRca1 === currentRca2 && currentRca1 !== '53') {
                            targetRcaCode = currentRca1;
                        } 
                        else if (observacaoFor === 'PEPSICO') {
                            if (currentRca1 && currentRca1 !== '53') {
                                targetRcaCode = currentRca1;
                            }
                        } 
                        else if (observacaoFor === 'MULTIMARCAS') {
                            if (currentRca2 && currentRca2 !== '53') {
                                targetRcaCode = currentRca2;
                            }
                        }
                        
                        if (targetRcaCode && rcaInfoMap.has(targetRcaCode)) {
                            const newOwnerInfo = rcaInfoMap.get(targetRcaCode);
                            newSale['CODUSUR'] = targetRcaCode;
                            newSale['NOME'] = newOwnerInfo.NOME;
                            newSale['SUPERV'] = newOwnerInfo.SUPERV;
                        }
                        
                        return newSale;
                    }
                    return sale;
                });

                self.postMessage({ type: 'progress', status: 'Cruzando dados de vendas...', percentage: 70 });
                const processedSalesData = processSalesData(salesDataRaw, clientMap, productMasterMap);
                const processedHistoryData = processSalesData(reattributedHistoryDataRaw, clientMap, productMasterMap);

                self.postMessage({ type: 'progress', status: 'Atualizando datas de compra...', percentage: 80 });
                const latestSaleDateByClient = new Map();
                processedSalesData.forEach(sale => {
                    const codcli = sale.CODCLI;
                    const saleDate = parseDate(sale.DTPED);
                    if (codcli && saleDate) {
                        const existingDate = latestSaleDateByClient.get(codcli);
                        if (!existingDate || saleDate > existingDate) latestSaleDateByClient.set(codcli, saleDate);
                    }
                });
                clientMap.forEach((client, codcli) => {
                    const lastPurchaseDate = parseDate(client.ultimaCompra);
                    const latestSaleDate = latestSaleDateByClient.get(codcli);
                    if (latestSaleDate && (!lastPurchaseDate || isNaN(lastPurchaseDate.getTime()) || latestSaleDate > lastPurchaseDate)) {
                        client.ultimaCompra = latestSaleDate;
                    }
                });
                
                self.postMessage({ type: 'progress', status: 'Agregando pedidos...', percentage: 90 });
                const aggregateOrders = (data) => {
                    const orders = {};
                    data.forEach(row => {
                        if (!row.PEDIDO) return;
                        if (!orders[row.PEDIDO]) {
                            orders[row.PEDIDO] = { ...row, QTVENDA: 0, VLVENDA: 0, TOTPESOLIQ: 0, FORNECEDORES: new Set() };
                        }
                        orders[row.PEDIDO].QTVENDA += row.QTVENDA;
                        orders[row.PEDIDO].VLVENDA += row.VLVENDA;
                        orders[row.PEDIDO].TOTPESOLIQ += row.TOTPESOLIQ;
                        if (row.OBSERVACAOFOR) orders[row.PEDIDO].FORNECEDORES.add(row.OBSERVACAOFOR);
                    });
                    return Object.values(orders).map(order => {
                        order.FORNECEDORES_LIST = Array.from(order.FORNECEDORES);
                        order.FORNECEDORES_STR = order.FORNECEDORES_LIST.join(', ');
                        return order;
                    });
                };
                const aggregatedByOrder = aggregateOrders(processedSalesData);
                
                self.postMessage({ type: 'progress', status: 'Finalizando...', percentage: 100 });
                
                self.postMessage({
                    type: 'result',
                    data: {
                        detailed: processedSalesData,
                        history: processedHistoryData,
                        byOrder: aggregatedByOrder,
                        clients: Array.from(clientMap.values()),
                        stockMap05: Object.fromEntries(stockMap05),
                        stockMap08: Object.fromEntries(stockMap08)
                    }
                });

            } catch (error) {
                self.postMessage({ type: 'error', message: error.message + (error.stack ? `\nStack: ${error.stack}`: '') });
            }
        };
    </script>

    <script id="report-logic-script" type="text/template">
        // A SER PREENCHIDO NA PARTE 2
    </script>

    <script>
        // A SER PREENCHIDO NA PARTE 3
    </script>
</body>
</html>
