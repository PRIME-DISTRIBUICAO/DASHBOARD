<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de Relatório Otimizado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .file-input-label { display: block; text-align: left; font-size: 0.875rem; font-weight: 500; color: #cbd5e1; margin-bottom: 0.5rem; }
        .progress-bar-container { background-color: #1e293b; border-radius: 0.5rem; overflow: hidden; }
        .progress-bar { background-color: #14b8a6; height: 100%; transition: width 0.3s ease-in-out; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 flex items-center justify-center min-h-screen">
    <div class="text-center p-8 bg-slate-800 rounded-lg shadow-2xl max-w-lg w-full m-4">
        <h1 class="text-2xl font-bold text-white mb-4">Gerador de Relatório Otimizado</h1>
        <p class="text-slate-400 mb-6">Carregue os arquivos para gerar um dashboard offline. O processamento agora ocorre em segundo plano, sem travar a interface.</p>
        
        <div class="space-y-4 mb-6">
            <div>
                <label for="sales-file-input" class="file-input-label">1. Arquivo de Vendas (Mês Atual)</label>
                <input type="file" id="sales-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="clients-file-input" class="file-input-label">2. Cadastro de Clientes</label>
                <input type="file" id="clients-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="products-file-input" class="file-input-label">3. Cadastro de Produtos</label>
                <input type="file" id="products-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
            <div>
                <label for="history-file-input" class="file-input-label">4. Histórico de Vendas (Trimestre Anterior)</label>
                <input type="file" id="history-file-input" class="block w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-slate-700 file:text-slate-200 hover:file:bg-slate-600" accept=".csv, .xls, .xlsx"/>
            </div>
             </div>
        
        <button id="generate-btn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded-lg w-full disabled:bg-slate-600" disabled>
            Gerar Relatório
        </button>

        <div id="status-container" class="hidden mt-6 text-sm h-12 flex flex-col justify-center">
            <p id="status-text" class="mb-2"></p>
            <div class="progress-bar-container w-full h-2">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
        </div>

        <div id="download-container" class="hidden mt-6 border-t border-slate-700 pt-6">
            <a id="download-link" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-6 rounded-lg w-full inline-block">
                Baixar Relatório HTML
            </a>
        </div>
    </div>

    <script id="worker-script" type="text/worker-javascript">
        // Importa a biblioteca para ler arquivos XLSX
        self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js');

        // Função para parsear datas (executada dentro do worker)
        function parseDate(dateString) {
            if (!dateString) return null;
            if (dateString instanceof Date) return !isNaN(dateString.getTime()) ? dateString : null;
            if (typeof dateString === 'number') return new Date(Math.round((dateString - 25569) * 86400 * 1000));
            if (typeof dateString !== 'string') return null;
            
            const parts = dateString.split('/');
            if (parts.length === 3) {
                const [day, month, year] = parts;
                if (day.length === 2 && month.length === 2 && year.length === 4) return new Date(`${year}-${month}-${day}T00:00:00`);
            }
            
            const isoDate = new Date(dateString);
            return !isNaN(isoDate.getTime()) ? isoDate : null;
        }
        
        // Função para parsear números no formato brasileiro (executada dentro do worker)
        function parseBrazilianNumber(value) {
            if (typeof value === 'number') return value;
            if (typeof value !== 'string' || !value) return 0;
            const cleaned = String(value).replace(/R\$\s?/g, '').trim();
            const lastComma = cleaned.lastIndexOf(',');
            const lastDot = cleaned.lastIndexOf('.');
            let numberString;
            if (lastComma > lastDot) {
                numberString = cleaned.replace(/\./g, '').replace(',', '.');
            } else if (lastDot > lastComma) {
                numberString = cleaned.replace(/,/g, '');
            } else {
                numberString = cleaned.replace(',', '.');
            }
            const number = parseFloat(numberString);
            return isNaN(number) ? 0 : number;
        }

        // Função para ler o conteúdo de um arquivo (executada dentro do worker)
        const readFile = (file) => {
            return new Promise((resolve, reject) => {
                if (!file) {
                    resolve([]); // Resolve with empty array if no file is provided
                    return;
                }
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let jsonData;
                        const data = event.target.result;
                        if (file.name.endsWith('.csv')) {
                            let decodedData;
                            try {
                                decodedData = new TextDecoder('utf-8').decode(new Uint8Array(data));
                                if (decodedData.includes(' ')) { 
                                    throw new Error('UTF-8 decoding failed, trying ISO-8859-1');
                                }
                            } catch (e) {
                                decodedData = new TextDecoder('iso-8859-1').decode(new Uint8Array(data));
                            }
                            
                            const lines = decodedData.split(/\r?\n/).filter(line => line.trim() !== '');
                            if (lines.length < 1) {
                                resolve([]);
                                return;
                            };
                            
                            const firstLine = lines[0];
                            const delimiter = firstLine.includes(';') ? ';' : ',';

                            const headers = lines.shift().trim().split(delimiter).map(h => h.replace(/"/g, ''));
                            jsonData = lines.map(line => {
                                const values = line.trim().split(delimiter).map(v => v.replace(/"/g, ''));
                                let row = {};
                                headers.forEach((header, index) => {
                                    row[header.trim()] = values[index] || null;
                                });
                                return row;
                            });
                        } else {
                            const workbook = XLSX.read(new Uint8Array(data), {type: 'array'});
                            const firstSheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[firstSheetName];
                            jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, cellDates: true });
                        }
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error(`Erro ao ler o arquivo '${file.name}'.`));
                reader.readAsArrayBuffer(file);
            });
        };

        // Função principal de processamento de dados de vendas (executada dentro do worker)
        const processSalesData = (rawData, clientMap, productMasterMap) => {
            return rawData.map(rawRow => {
                const clientInfo = clientMap.get(String(rawRow['CODCLI'])) || {};
                let vendorName = String(rawRow['NOME'] || '');
                let supervisorName = String(rawRow['SUPERV'] || '');
                let codUsur = String(rawRow['CODUSUR'] || '');
                const pedido = String(rawRow['PEDIDO'] || '');
                if (supervisorName.trim().toUpperCase() === 'OSÉAS SANTOS OL') supervisorName = 'OSVALDO NUNES O';
                const nomeClienteParaLogica = (clientInfo.razaoSocial || '').toUpperCase();
                const supervisorUpper = (supervisorName || '').trim().toUpperCase();
                if (supervisorUpper === 'BALCAO' || supervisorUpper === 'BALCÃO') supervisorName = 'BALCAO';
                if (supervisorName === 'BALCAO' && nomeClienteParaLogica.includes('AMERICANAS')) { vendorName = 'AMERICANAS'; codUsur = '1001'; }
                if (pedido.startsWith('120')) { vendorName = 'VD HIAGO'; supervisorName = 'HIAGO ASSUNCAO'; codUsur = '1002'; }
                let dtPed = rawRow['DTPED'];
                const dtSaida = rawRow['DTSAIDA'];
                const parsedDtPed = parseDate(dtPed);
                const parsedDtSaida = parseDate(dtSaida);
                if (parsedDtPed && parsedDtSaida && (parsedDtPed.getFullYear() < parsedDtSaida.getFullYear() || (parsedDtPed.getFullYear() === parsedDtSaida.getFullYear() && parsedDtPed.getMonth() < parsedDtSaida.getMonth()))) {
                    dtPed = dtSaida;
                }
                const productCode = String(rawRow['PRODUTO'] || '');
                const qtdeMaster = productMasterMap.get(productCode) || 1;
                const qtVenda = parseInt(String(rawRow['QTVENDA'] || '0').trim(), 10);
                return {
                    PEDIDO: pedido, NOME: vendorName, SUPERV: supervisorName, PRODUTO: productCode,
                    DESCRICAO: String(rawRow['DESCRICAO'] || ''), FORNECEDOR: String(rawRow['FORNECEDOR'] || ''),
                    OBSERVACAOFOR: String(rawRow['OBSERVACAOFOR'] || '').trim(), CODFOR: String(rawRow['CODFOR'] || ''),
                    CODUSUR: codUsur, CODCLI: String(rawRow['CODCLI'] || ''), CLIENTE_NOME: clientInfo.nomeCliente || 'N/A',
                    CIDADE: clientInfo.cidade || 'N/A', BAIRRO: clientInfo.bairro || 'N/A',
                    QTVENDA: qtVenda, VLVENDA: parseBrazilianNumber(rawRow['VLVENDA']),
                    TOTPESOLIQ: parseBrazilianNumber(rawRow['TOTPESOLIQ']), DTPED: dtPed, DTSAIDA: dtSaida, 
                    POSICAO: String(rawRow['POSICAO'] || ''),
                    FILIAL: String(rawRow['FILIAL'] || ''),
                    ESTOQUECX: parseBrazilianNumber(rawRow['ESTOQUECX']),
                    ESTOQUEUNIT: parseBrazilianNumber(rawRow['ESTOQUEUNIT']),
                    QTVENDA_EMBALAGEM_MASTER: isNaN(qtdeMaster) || qtdeMaster === 0 ? 0 : qtVenda / qtdeMaster
                };
            });
        };

        // Event listener que aguarda mensagens da página principal
        self.onmessage = async (event) => {
            const { salesFile, clientsFile, productsFile, historyFile } = event.data;

            try {
                self.postMessage({ type: 'progress', status: 'Lendo arquivos...', percentage: 10 });
                const [salesDataRaw, clientsDataRaw, productsDataRaw, historyDataRaw] = await Promise.all([
                    readFile(salesFile),
                    readFile(clientsFile),
                    readFile(productsFile),
                    readFile(historyFile)
                ]);
                
                self.postMessage({ type: 'progress', status: 'Extraindo estoque do arquivo de vendas...', percentage: 25 });
                const stockMap05 = new Map();
                const stockMap08 = new Map();

                salesDataRaw.forEach(item => {
                    const productCode = String(item['PRODUTO'] || '').trim();
                    const branch = String(item['FILIAL'] || '').trim();
                    const stockQtyCx = parseBrazilianNumber(item['ESTOQUECX']);

                    if (productCode && branch) {
                        if (branch.includes('5')) {
                            stockMap05.set(productCode, stockQtyCx);
                        } else if (branch.includes('8')) {
                            stockMap08.set(productCode, stockQtyCx);
                        }
                    }
                });

                self.postMessage({ type: 'progress', status: 'Mapeando produtos...', percentage: 30 });
                const productMasterMap = new Map();
                productsDataRaw.forEach(prod => {
                    const productCode = String(prod['Código'] || '');
                    if (!productCode) return;
                    let qtdeMaster = parseInt(prod['Qtde embalagem master(Compra)'], 10);
                    if (isNaN(qtdeMaster) || qtdeMaster <= 0) qtdeMaster = 1;
                    productMasterMap.set(productCode, qtdeMaster);
                });

                const clientRcaOverrides = new Map();
                salesDataRaw.forEach(rawRow => {
                    const pedido = String(rawRow['PEDIDO'] || '');
                    const codCli = String(rawRow['CODCLI'] || '');
                    if(!codCli) return;
                    if (pedido.startsWith('120')) clientRcaOverrides.set(codCli, '1002');
                });

                self.postMessage({ type: 'progress', status: 'Processando clientes...', percentage: 50 });
                const clientMap = new Map();
                clientsDataRaw.forEach(client => {
                    const codCli = String(client['Código'] || '');
                    if (!codCli) return;

                    const rca1 = String(client['RCA 1'] || '');
                    const rca2 = String(client['RCA 2'] || '');
                    const rcas = new Set();
                    if (rca1) rcas.add(rca1);
                    if (rca2) rcas.add(rca2);

                    let registrationDateStr = client['Data e Hora de Cadastro'] || '';
                    if (registrationDateStr.includes(' ')) registrationDateStr = registrationDateStr.split(' ')[0];
                    
                    const clientData = {
                        'Código': codCli,
                        rcas: Array.from(rcas),
                        rca1: rca1, 
                        rca2: rca2, 
                        cidade: String(client['Nome da Cidade'] || 'N/A'),
                        nomeCliente: String(client['Fantasia'] || client['Cliente'] || 'N/A'),
                        bairro: String(client['Bairro'] || 'N/A'),
                        razaoSocial: String(client['Cliente'] || 'N/A'),
                        fantasia: String(client['Fantasia'] || 'N/A'),
                        cnpj_cpf: String(client['CNPJ/CPF'] || 'N/A'),
                        endereco: String(client['Endereço Comercial'] || client['Endereço'] || 'N/A'),
                        numero: String(client['Número'] || 'SN'),
                        cep: String(client['CEP'] || 'N/A'),
                        telefone: String(client['Telefone Comercial'] || 'N/A'),
                        email: String(client['E-mail'] || 'N/A'),
                        ramo: String(client['Descricao'] || 'N/A'),
                        ultimaCompra: client['Data da Última Compra'],
                        dataCadastro: registrationDateStr,
                        bloqueio: String(client['Bloqueio'] || '').trim().toUpperCase(),
                        inscricaoEstadual: String(client['Insc. Est. / Produtor'] || 'N/A')
                    };
                    if (clientRcaOverrides.has(codCli)) clientData.rcas.unshift(clientRcaOverrides.get(codCli));
                    if (clientData.razaoSocial.toUpperCase().includes('AMERICANAS')) clientData.rcas.unshift('1001');
                    clientMap.set(codCli, clientData);
                });

                self.postMessage({ type: 'progress', status: 'Mapeando vendedores...', percentage: 60 });
                const rcaInfoMap = new Map();
                [...salesDataRaw, ...historyDataRaw].forEach(row => {
                    const codusur = String(row['CODUSUR'] || '').trim();
                    if (codusur && !rcaInfoMap.has(codusur)) {
                        rcaInfoMap.set(codusur, {
                            NOME: String(row['NOME'] || ''),
                            SUPERV: String(row['SUPERV'] || '')
                        });
                    }
                });

                self.postMessage({ type: 'progress', status: 'Reatribuindo vendas do trimestre...', percentage: 65 });
                const reattributedHistoryDataRaw = historyDataRaw.map(sale => {
                    const codCli = String(sale['CODCLI'] || '');
                    const clientData = clientMap.get(codCli);
                    const observacaoFor = String(sale['OBSERVACAOFOR'] || '').trim().toUpperCase();

                    if (clientData) {
                        const newSale = { ...sale };
                        let targetRcaCode = null;

                        const currentRca1 = clientData.rca1;
                        const currentRca2 = clientData.rca2;

                        if (currentRca1 && currentRca1 === currentRca2 && currentRca1 !== '53') {
                            targetRcaCode = currentRca1;
                        } 
                        else if (observacaoFor === 'PEPSICO') {
                            if (currentRca1 && currentRca1 !== '53') {
                                targetRcaCode = currentRca1;
                            }
                        } 
                        else if (observacaoFor === 'MULTIMARCAS') {
                            if (currentRca2 && currentRca2 !== '53') {
                                targetRcaCode = currentRca2;
                            }
                        }
                        
                        if (targetRcaCode && rcaInfoMap.has(targetRcaCode)) {
                            const newOwnerInfo = rcaInfoMap.get(targetRcaCode);
                            newSale['CODUSUR'] = targetRcaCode;
                            newSale['NOME'] = newOwnerInfo.NOME;
                            newSale['SUPERV'] = newOwnerInfo.SUPERV;
                        }
                        
                        return newSale;
                    }
                    return sale;
                });

                self.postMessage({ type: 'progress', status: 'Cruzando dados de vendas...', percentage: 70 });
                const processedSalesData = processSalesData(salesDataRaw, clientMap, productMasterMap);
                const processedHistoryData = processSalesData(reattributedHistoryDataRaw, clientMap, productMasterMap);

                self.postMessage({ type: 'progress', status: 'Atualizando datas de compra...', percentage: 80 });
                const latestSaleDateByClient = new Map();
                processedSalesData.forEach(sale => {
                    const codcli = sale.CODCLI;
                    const saleDate = parseDate(sale.DTPED);
                    if (codcli && saleDate) {
                        const existingDate = latestSaleDateByClient.get(codcli);
                        if (!existingDate || saleDate > existingDate) latestSaleDateByClient.set(codcli, saleDate);
                    }
                });
                clientMap.forEach((client, codcli) => {
                    const lastPurchaseDate = parseDate(client.ultimaCompra);
                    const latestSaleDate = latestSaleDateByClient.get(codcli);
                    if (latestSaleDate && (!lastPurchaseDate || isNaN(lastPurchaseDate.getTime()) || latestSaleDate > lastPurchaseDate)) {
                        client.ultimaCompra = latestSaleDate;
                    }
                });
                
                self.postMessage({ type: 'progress', status: 'Agregando pedidos...', percentage: 90 });
                const aggregateOrders = (data) => {
                    const orders = {};
                    data.forEach(row => {
                        if (!row.PEDIDO) return;
                        if (!orders[row.PEDIDO]) {
                            orders[row.PEDIDO] = { ...row, QTVENDA: 0, VLVENDA: 0, TOTPESOLIQ: 0, FORNECEDORES: new Set() };
                        }
                        orders[row.PEDIDO].QTVENDA += row.QTVENDA;
                        orders[row.PEDIDO].VLVENDA += row.VLVENDA;
                        orders[row.PEDIDO].TOTPESOLIQ += row.TOTPESOLIQ;
                        if (row.OBSERVACAOFOR) orders[row.PEDIDO].FORNECEDORES.add(row.OBSERVACAOFOR);
                    });
                    return Object.values(orders).map(order => {
                        order.FORNECEDORES_LIST = Array.from(order.FORNECEDORES);
                        order.FORNECEDORES_STR = order.FORNECEDORES_LIST.join(', ');
                        return order;
                    });
                };
                const aggregatedByOrder = aggregateOrders(processedSalesData);
                
                self.postMessage({ type: 'progress', status: 'Finalizando...', percentage: 100 });
                
                self.postMessage({
                    type: 'result',
                    data: {
                        detailed: processedSalesData,
                        history: processedHistoryData,
                        byOrder: aggregatedByOrder,
                        clients: Array.from(clientMap.values()),
                        stockMap05: Object.fromEntries(stockMap05),
                        stockMap08: Object.fromEntries(stockMap08)
                    }
                });

            } catch (error) {
                self.postMessage({ type: 'error', message: error.message + (error.stack ? `\nStack: ${error.stack}`: '') });
            }
        };
    </script>

    <script id="report-logic-script" type="text/template">
                const allSalesData = embeddedData.detailed;
        const allHistoryData = embeddedData.history;
        const aggregatedOrders = embeddedData.byOrder;
        const allClientsData = embeddedData.clients;
        const stockData05 = new Map(Object.entries(embeddedData.stockMap05 || {}));
        const stockData08 = new Map(Object.entries(embeddedData.stockMap08 || {}));
        const clientMapForKPIs = new Map(allClientsData.map(c => [String(c['Código']), c]));

        aggregatedOrders.sort((a, b) => {
            const dateA = parseDate(a.DTPED);
            const dateB = parseDate(b.DTPED);
            if (!dateA) return 1;
            if (!dateB) return -1;
            return dateB - dateA;
        });

        Chart.register(ChartDataLabels);

        const mainDashboard = document.getElementById('main-dashboard');
        const cityView = document.getElementById('city-view');
        const weeklyView = document.getElementById('weekly-view');
        const comparisonView = document.getElementById('comparison-view');
        const stockView = document.getElementById('stock-view'); // NOVA VIEW
        
        const showWeeklyBtn = document.getElementById('show-weekly-btn');
        const showCityBtn = document.getElementById('show-city-btn');
        const backToMainFromCityBtn = document.getElementById('back-to-main-from-city-btn');
        const backToMainFromWeeklyBtn = document.getElementById('back-to-main-from-weekly-btn');
        const backToMainFromComparisonBtn = document.getElementById('back-to-main-from-comparison-btn');
        const backToMainFromStockBtn = document.getElementById('back-to-main-from-stock-btn'); //NOVO

        const totalVendasEl = document.getElementById('total-vendas');
        const totalPesoEl = document.getElementById('total-peso');
        const viewChartBtn = document.getElementById('viewChartBtn');
        const viewTableBtn = document.getElementById('viewTableBtn');
        const viewComparisonBtn = document.getElementById('viewComparisonBtn');
        const viewStockBtn = document.getElementById('viewStockBtn'); // NOVO BOTAO
        const chartView = document.getElementById('chartView');
        const tableView = document.getElementById('tableView');
        const faturamentoBtn = document.getElementById('faturamentoBtn');
        const pesoBtn = document.getElementById('pesoBtn');
        
        const supervisorFilter = document.getElementById('supervisor-filter');
        const vendedorFilterBtn = document.getElementById('vendedor-filter-btn');
        const vendedorFilterText = document.getElementById('vendedor-filter-text');
        const vendedorFilterDropdown = document.getElementById('vendedor-filter-dropdown');
        
        const mainRedeGroupContainer = document.getElementById('main-rede-group-container');
        const mainComRedeBtn = document.getElementById('main-com-rede-btn');
        const mainComRedeBtnText = document.getElementById('main-com-rede-btn-text');
        const mainRedeFilterDropdown = document.getElementById('main-rede-filter-dropdown');

        const posicaoFilter = document.getElementById('posicao-filter');
        const codcliFilter = document.getElementById('codcli-filter');
        const clearFiltersBtn = document.getElementById('clear-filters-btn');
        const salesByPersonTitle = document.getElementById('sales-by-person-title');
        const fornecedorToggleContainer = document.getElementById('fornecedor-toggle-container');
        
        const citySupervisorFilter = document.getElementById('city-supervisor-filter');
        const cityVendedorFilterBtn = document.getElementById('city-vendedor-filter-btn');
        const cityVendedorFilterText = document.getElementById('city-vendedor-filter-text');
        const cityVendedorFilterDropdown = document.getElementById('city-vendedor-filter-dropdown');
        const cityNameFilter = document.getElementById('city-name-filter');
        const cityCodCliFilter = document.getElementById('city-codcli-filter');
        const citySuggestions = document.getElementById('city-suggestions');
        const clearCityFiltersBtn = document.getElementById('clear-city-filters-btn');
        const totalFaturamentoCidadeEl = document.getElementById('total-faturamento-cidade');
        const cityActiveDetailTableBody = document.getElementById('city-active-detail-table-body');
        const cityInactiveDetailTableBody = document.getElementById('city-inactive-detail-table-body');
        
        const cityRedeGroupContainer = document.getElementById('city-rede-group-container');
        const cityComRedeBtn = document.getElementById('city-com-rede-btn');
        const cityComRedeBtnText = document.getElementById('city-com-rede-btn-text');
        const cityRedeFilterDropdown = document.getElementById('city-rede-filter-dropdown');

        const weeklySupervisorFilter = document.getElementById('weekly-supervisor-filter');
        const clearWeeklyFiltersBtn = document.getElementById('clear-weekly-filters-btn');
        const totalMesSemanalEl = document.getElementById('total-mes-semanal');
        const weeklyFornecedorToggleContainer = document.getElementById('weekly-fornecedor-toggle-container');
        
        const comparisonSupervisorFilter = document.getElementById('comparison-supervisor-filter');
        const comparisonVendedorFilterBtn = document.getElementById('comparison-vendedor-filter-btn');
        const comparisonVendedorFilterText = document.getElementById('comparison-vendedor-filter-text');
        const comparisonVendedorFilterDropdown = document.getElementById('comparison-vendedor-filter-dropdown');
        const comparisonFornecedorToggleContainer = document.getElementById('comparison-fornecedor-toggle-container');
        
        const comparisonSupplierFilterBtn = document.getElementById('comparison-supplier-filter-btn');
        const comparisonSupplierFilterText = document.getElementById('comparison-supplier-filter-text');
        const comparisonSupplierFilterDropdown = document.getElementById('comparison-supplier-filter-dropdown');

        const comparisonCityFilter = document.getElementById('comparison-city-filter');
        const comparisonCitySuggestions = document.getElementById('comparison-city-suggestions');
        const comparisonProductFilterBtn = document.getElementById('comparison-product-filter-btn');
        const comparisonProductFilterText = document.getElementById('comparison-product-filter-text');
        const comparisonProductFilterDropdown = document.getElementById('comparison-product-filter-dropdown');
        
        const comparisonRedeGroupContainer = document.getElementById('comparison-rede-group-container');
        const comparisonComRedeBtn = document.getElementById('comparison-com-rede-btn');
        const comparisonComRedeBtnText = document.getElementById('comparison-com-rede-btn-text');
        const comparisonRedeFilterDropdown = document.getElementById('comparison-rede-filter-dropdown');

        const clearComparisonFiltersBtn = document.getElementById('clear-comparison-filters-btn');
        const comparisonTendencyToggle = document.getElementById('comparison-tendency-toggle');
        
        const comparisonChartTitle = document.getElementById('comparison-chart-title');
        const toggleWeeklyBtn = document.getElementById('toggle-weekly-btn');
        const toggleMonthlyBtn = document.getElementById('toggle-monthly-btn');
        const weeklyComparisonChartContainer = document.getElementById('weeklyComparisonChartContainer');
        const monthlyComparisonChartContainer = document.getElementById('monthlyComparisonChartContainer');
        
        const filialFilter = document.getElementById('filial-filter');

        // NOVOS ELEMENTOS DA TELA DE ESTOQUE
        const stockFilialFilter = document.getElementById('stock-filial-filter');
        const stockSupplierFilterBtn = document.getElementById('stock-supplier-filter-btn');
        const stockSupplierFilterText = document.getElementById('stock-supplier-filter-text');
        const stockSupplierFilterDropdown = document.getElementById('stock-supplier-filter-dropdown');
        const stockProductFilterBtn = document.getElementById('stock-product-filter-btn');
        const stockProductFilterText = document.getElementById('stock-product-filter-text');
        const stockProductFilterDropdown = document.getElementById('stock-product-filter-dropdown');
        const clearStockFiltersBtn = document.getElementById('clear-stock-filters-btn');
        const stockAnalysisTableBody = document.getElementById('stock-analysis-table-body');


        const modal = document.getElementById('order-details-modal');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalPedidoId = document.getElementById('modal-pedido-id');
        const modalHeaderInfo = document.getElementById('modal-header-info');
        const modalTableBody = document.getElementById('modal-table-body');
        const modalFooterTotal = document.getElementById('modal-footer-total');
        
        const clientModal = document.getElementById('client-details-modal');
        const clientModalCloseBtn = document.getElementById('client-modal-close-btn');
        const clientModalContent = document.getElementById('client-modal-content');

        const holidayModal = document.getElementById('holiday-modal');
        const holidayModalCloseBtn = document.getElementById('holiday-modal-close-btn');
        const holidayModalDoneBtn = document.getElementById('holiday-modal-done-btn');
        const mainHolidayPickerBtn = document.getElementById('main-holiday-picker-btn');
        const comparisonHolidayPickerBtn = document.getElementById('comparison-holiday-picker-btn');
        const calendarContainer = document.getElementById('calendar-container');

        let charts = {};
        let currentProductMetric = 'faturamento';
        let currentFornecedor = '';
        let currentWeeklyFornecedor = '';
        let currentComparisonFornecedor = '';
        let useTendencyComparison = false;
        let comparisonChartType = 'weekly';
        let activeClientsForExport = [];
        let inactiveClientsForExport = [];
        let selectedSellers = [];
        let selectedCitySellers = [];
        let selectedComparisonSellers = [];
        let selectedComparisonSuppliers = [];
        let selectedComparisonProducts = [];
        let selectedStockSuppliers = []; // NOVO
        let selectedStockProducts = []; // NOVO
        let historicalBests = {};
        let selectedHolidays = [];
        
        let selectedMainRedes = [];
        let selectedCityRedes = [];
        let selectedComparisonRedes = [];

        let mainRedeGroupFilter = '';
        let cityRedeGroupFilter = ''; 
        let comparisonRedeGroupFilter = '';
        
        const lastSaleDate = allSalesData.length > 0 ? new Date(Math.max.apply(null, allSalesData.map(s => parseDate(s.DTPED)).filter(d => d && !isNaN(d)))) : new Date();
        lastSaleDate.setHours(0,0,0,0);
        let calendarState = { year: lastSaleDate.getFullYear(), month: lastSaleDate.getMonth() };
        
        const getFirstName = (fullName) => (fullName || '').split(' ')[0];

        function parseDate(dateString) {
            if (!dateString) return null;
            if (dateString instanceof Date) return !isNaN(dateString.getTime()) ? dateString : null;
            if (typeof dateString === 'number') return new Date(Math.round((dateString - 25569) * 86400 * 1000));
            if (typeof dateString !== 'string') return null;
            const parts = dateString.split('/');
            if (parts.length === 3) {
                const [day, month, year] = parts;
                if (day.length === 2 && month.length === 2 && year.length === 4) return new Date(`${year}-${month}-${day}T00:00:00`);
            }
            const isoDate = new Date(dateString);
            return !isNaN(isoDate.getTime()) ? isoDate : null;
        }

        function formatDate(date) {
            if (!date) return '';
            const d = parseDate(date);
            if (!d || isNaN(d.getTime())) return '';
            const userTimezoneOffset = d.getTimezoneOffset() * 60000;
            return new Date(d.getTime() + userTimezoneOffset).toLocaleDateString('pt-BR');
        }
        
        function getUniqueMonthCount(data) {
            const months = new Set();
            data.forEach(sale => {
                const saleDate = parseDate(sale.DTPED);
                if (saleDate) {
                    const monthKey = `${saleDate.getFullYear()}-${saleDate.getMonth()}`;
                    months.add(monthKey);
                }
            });
            return months.size > 0 ? months.size : 1;
        }

        function calculateSummaryFromData(data, isFiltered) {
            const summary = { 
                totalFaturamento: 0, totalPeso: 0, vendasPorVendedor: {}, vendasPorSupervisor: {}, 
                top10ProdutosFaturamento: [], top10ProdutosPeso: [], faturamentoPorFornecedor: {} 
            };
            const salesByProduct = {};
            const faturamentoMap = new Map();

            data.forEach(item => {
                summary.totalFaturamento += item.VLVENDA;
                summary.totalPeso += item.TOTPESOLIQ;

                const vendedor = item.NOME || 'N/A';
                summary.vendasPorVendedor[vendedor] = (summary.vendasPorVendedor[vendedor] || 0) + item.VLVENDA;

                const supervisor = item.SUPERV || 'N/A';
                summary.vendasPorSupervisor[supervisor] = (summary.vendasPorSupervisor[supervisor] || 0) + item.VLVENDA;

                const produto = item.DESCRICAO || 'N/A';
                const codigo = item.PRODUTO || 'N/A';
                if (!salesByProduct[produto]) salesByProduct[produto] = { faturamento: 0, peso: 0, codigo: codigo };
                salesByProduct[produto].faturamento += item.VLVENDA;
                salesByProduct[produto].peso += item.TOTPESOLIQ;

                let fornecedorLabel;
                if(isFiltered){
                    const fornecedorNome = item.FORNECEDOR || 'N/A';
                    const codFor = item.CODFOR;
                    fornecedorLabel = `${fornecedorNome} - ${codFor}`;
                } else {
                     fornecedorLabel = item.OBSERVACAOFOR || 'N/A';
                }
                
                const currentTotal = faturamentoMap.get(fornecedorLabel) || 0;
                faturamentoMap.set(fornecedorLabel, currentTotal + item.VLVENDA);
            });

            summary.faturamentoPorFornecedor = Object.fromEntries(faturamentoMap);
            summary.top10ProdutosFaturamento = Object.entries(salesByProduct).sort(([,a],[,b]) => b.faturamento - a.faturamento).slice(0, 10).map(([p, d]) => ({ produto: p, ...d }));
            summary.top10ProdutosPeso = Object.entries(salesByProduct).sort(([,a],[,b]) => b.peso - a.peso).slice(0, 10).map(([p, d]) => ({ produto: p, ...d }));
            return summary;
        }

        const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);
        const mergeDeep = (...objects) => {
            return objects.reduce((prev, obj) => {
                Object.keys(obj).forEach(key => {
                    const pVal = prev[key];
                    const oVal = obj[key];
                    if (isObject(pVal) && isObject(oVal)) prev[key] = mergeDeep(pVal, oVal);
                    else prev[key] = oVal;
                });
                return prev;
            }, {});
        };
        
        function createChart(canvasId, type, labels, chartData, optionsOverrides = {}, pluginsToRegister = []) {
            const container = document.getElementById(canvasId + 'Container');
            if (!container) return;
            if (charts[canvasId]) charts[canvasId].destroy();
            
            if (pluginsToRegister.length > 0) {
                Chart.register(...pluginsToRegister);
            }

            container.innerHTML = '';
            const newCanvas = document.createElement('canvas');
            newCanvas.id = canvasId;
            container.appendChild(newCanvas);
            container.style.display = ''; container.style.alignItems = ''; container.style.justifyContent = '';
            const ctx = newCanvas.getContext('2d');
            const professionalPalette = ['#14b8a6', '#6366f1', '#ec4899', '#f97316', '#8b5cf6', '#06b6d4', '#f59e0b', '#ef4444', '#22c55e'];

            let finalDatasets;
            if (Array.isArray(chartData) && chartData.length > 0 && typeof chartData[0] === 'object' && chartData[0].hasOwnProperty('label')) {
                finalDatasets = chartData.map((dataset, index) => ({ ...dataset, backgroundColor: dataset.backgroundColor || professionalPalette[index % professionalPalette.length], borderColor: dataset.borderColor || professionalPalette[index % professionalPalette.length] }));
            } else {
                 finalDatasets = [{ data: chartData, backgroundColor: canvasId === 'customerStatusChart' ? ['#2dd4bf', '#f59e0b'] : professionalPalette }];
            }
            
            let baseOptions = { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false, labels: {color: '#cbd5e1'} }, datalabels: { display: false } }, scales: { y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.05)'} }, x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(255, 255, 255, 0.05)'} } } };
            let typeDefaults = {};
            if (type === 'bar') typeDefaults = { layout: { padding: { right: 30 } }, plugins: { datalabels: { display: true, anchor: 'end', align: 'end', offset: -4, color: '#cbd5e1', font: { size: 10 }, formatter: (v) => (v > 1000 ? (v/1000).toFixed(1) + 'k' : v.toFixed(0)) } } };
            if (type === 'doughnut') typeDefaults = { maintainAspectRatio: true, scales: { y: { display: false }, x: { display: false } }, plugins: { legend: { position: 'top', labels: { color: '#cbd5e1' } }, datalabels: { display: true, color: '#fff', font: { size: 11, weight: 'bold' }, formatter: (v, ctx) => { const total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0); if(total === 0 || v === 0) return ''; const p = (v / total) * 100; return p > 5 ? p.toFixed(0) + '%' : ''; } } } };
            const options = mergeDeep(baseOptions, typeDefaults, optionsOverrides);
            charts[canvasId] = new Chart(ctx, { type, data: { labels, datasets: finalDatasets }, options });
        }

        function showNoDataMessage(canvasId, message) {
            if (charts[canvasId]) charts[canvasId].destroy();
            const container = document.getElementById(canvasId + 'Container');
            if(container) {
                container.style.display = 'flex'; container.style.alignItems = 'center'; container.style.justifyContent = 'center';
                container.innerHTML = `<p class="text-slate-500">${message}</p>`;
            }
        }

        function updateProductBarChart(summary) {
            const metric = currentProductMetric;
            const data = metric === 'faturamento' ? summary.top10ProdutosFaturamento : summary.top10ProdutosPeso;
            const labels = data.map(p => `(${p.codigo}) ${p.produto}`);
            const values = data.map(p => p[metric]);
            createChart('salesByProductBarChart', 'bar', labels, values);
        }

        function renderTable(data) {
            const tableBody = document.getElementById('report-table-body');
            if (!tableBody) return;
            const getPosicaoBadge = (posicao) => {
                if (!posicao) return '<span>-</span>';
                let classes = '';
                switch (posicao) {
                    case 'L': classes = 'bg-green-500/20 text-green-300'; break;
                    case 'M': classes = 'bg-blue-500/20 text-blue-300'; break;
                    case 'F': classes = 'bg-yellow-500/20 text-yellow-300'; break;
                    default: return `<span>${posicao}</span>`;
                }
                return `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${classes}">${posicao}</span>`;
            };
            tableBody.innerHTML = data.map(row => `
                <tr class="hover:bg-slate-700">
                    <td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-pedido-id="${row.PEDIDO}">${row.PEDIDO}</a></td>
                    <td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${row.CODCLI}">${row.CODCLI}</a></td>
                    <td class="px-4 py-2">${getFirstName(row.NOME)}</td>
                    <td class="px-4 py-2">${row.FORNECEDORES_STR || ''}</td>
                    <td class="px-4 py-2">${formatDate(row.DTPED)}</td>
                    <td class="px-4 py-2">${formatDate(row.DTSAIDA)}</td>
                    <td class="px-4 py-2 text-right">${(row.TOTPESOLIQ || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} Kg</td>
                    <td class="px-4 py-2 text-right">${(row.VLVENDA || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td>
                    <td class="px-4 py-2 text-center">${getPosicaoBadge(row.POSICAO)}</td>
                </tr>
            `).join('');
        }

        function isHoliday(date, holidays) {
            if (!date || !holidays) return false;
            const dateString = date.toISOString().split('T')[0];
            return holidays.includes(dateString);
        }

        function getWorkingDaysInMonth(year, month, holidays) {
            let count = 0;
            const date = new Date(year, month, 1);
            while (date.getMonth() === month) {
                const dayOfWeek = date.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(date, holidays)) {
                    count++;
                }
                date.setDate(date.getDate() + 1);
            }
            return count;
        }
        
        function getPassedWorkingDaysInMonth(year, month, holidays, today) {
            let count = 0;
            const date = new Date(year, month, 1);
            while (date <= today && date.getMonth() === month) {
                const dayOfWeek = date.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(date, holidays)) {
                    count++;
                }
                date.setDate(date.getDate() + 1);
            }
            return count;
        }

        function updateTrendChart(currentSales, historicalSales) {
            const currentYear = lastSaleDate.getFullYear();
            const currentMonth = lastSaleDate.getMonth();
            const totalWorkingDays = getWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays);
            const passedWorkingDays = getPassedWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays, lastSaleDate);
            
            const monthCount = getUniqueMonthCount(historicalSales);
            const pastQuarterRevenue = historicalSales.reduce((sum, sale) => sum + sale.VLVENDA, 0);
            const averageMonthlyRevenue = monthCount > 0 ? pastQuarterRevenue / monthCount : 0;
            const currentMonthRevenue = currentSales.reduce((sum, sale) => sum + sale.VLVENDA, 0);
            const trend = passedWorkingDays > 0 && totalWorkingDays > 0 ? (currentMonthRevenue / passedWorkingDays) * totalWorkingDays : 0;
            const lineChartDataset = [{ label: 'Valor', data: [averageMonthlyRevenue, trend], fill: true, borderColor: '#14b8a6', backgroundColor: 'rgba(20, 184, 166, 0.1)', tension: 0.2, pointRadius: 6, pointBackgroundColor: '#14b8a6', pointBorderColor: '#FFF', pointBorderWidth: 2, pointHoverRadius: 8 }];
            const formatLabelValue = (v) => (v >= 1000000 ? (v / 1000000).toFixed(2) + ' M' : (v / 1000).toFixed(0) + 'k');
            
            createChart('trendChart', 'line', ['Média Faturamento Trimestre', 'Tendência Mês Atual'], lineChartDataset, { 
                layout: { padding: { top: 30 } },
                plugins: { 
                    legend: { display: false }, 
                    datalabels: { display: true, anchor: 'end', align: 'top', offset: 8, color: '#cbd5e1', font: { size: 12, weight: 'bold' }, formatter: formatLabelValue } 
                }, 
                scales: { 
                    y: { ticks: { callback: function(value) { if (value >= 1000000) return 'R$ ' + (value / 1000000).toFixed(1) + 'M'; return 'R$ ' + (value / 1000) + 'k'; } } }, 
                    x: { grid: { display: false } } 
                } 
            });
        }

        function updateAllVisuals() {
            const supervisor = supervisorFilter.value;
            const posicao = posicaoFilter.value;
            const codcli = codcliFilter.value.trim();
            
            let clientsForAnalysis = [...allClientsData];
            if (mainRedeGroupFilter === 'com_rede') {
                clientsForAnalysis = clientsForAnalysis.filter(c => c.ramo && c.ramo !== 'N/A');
                if (selectedMainRedes.length > 0) {
                    clientsForAnalysis = clientsForAnalysis.filter(c => selectedMainRedes.includes(c.ramo));
                }
            } else if (mainRedeGroupFilter === 'sem_rede') {
                clientsForAnalysis = clientsForAnalysis.filter(c => !c.ramo || c.ramo === 'N/A');
            }
            const clientCodesForAnalysis = new Set(clientsForAnalysis.map(c => c['Código']));

            let filteredSalesData = allSalesData.filter(s => clientCodesForAnalysis.has(s.CODCLI));
            let filteredHistoryData = allHistoryData.filter(s => clientCodesForAnalysis.has(s.CODCLI));

            if (codcli && !allClientsData.some(c => String(c['Código']) === codcli)) return;

            if (currentFornecedor) {
                 filteredSalesData = filteredSalesData.filter(row => String(row.OBSERVACAOFOR).trim() === currentFornecedor);
                 filteredHistoryData = filteredHistoryData.filter(row => String(row.OBSERVACAOFOR).trim() === currentFornecedor);
            }
            if (codcli) {
                filteredSalesData = filteredSalesData.filter(row => row.CODCLI === codcli);
                filteredHistoryData = filteredHistoryData.filter(row => row.CODCLI === codcli);
            } else {
                if (supervisor) {
                    filteredSalesData = filteredSalesData.filter(row => row.SUPERV === supervisor);
                    filteredHistoryData = filteredHistoryData.filter(row => row.SUPERV === supervisor);
                }
                if (selectedSellers.length > 0) {
                    filteredSalesData = filteredSalesData.filter(row => selectedSellers.includes(row.NOME));
                    filteredHistoryData = filteredHistoryData.filter(row => selectedSellers.includes(row.NOME));
                }
            }
            if (posicao) filteredSalesData = filteredSalesData.filter(row => row.POSICAO === posicao);
            
            const filteredTableData = aggregatedOrders.filter(order => {
                if(!clientCodesForAnalysis.has(order.CODCLI)) return false;
                let matches = true;
                if (codcli) matches = matches && order.CODCLI === codcli;
                else {
                    if (supervisor) matches = matches && order.SUPERV === supervisor;
                    if (selectedSellers.length > 0) matches = matches && selectedSellers.includes(order.NOME);
                }
                if (currentFornecedor) matches = matches && order.FORNECEDORES_LIST.includes(currentFornecedor);
                if (posicao) matches = matches && order.POSICAO === posicao;
                return matches;
            });
            
            const isFiltered = !!supervisor || selectedSellers.length > 0 || !!codcli || !!currentFornecedor || !!mainRedeGroupFilter;
            const summary = calculateSummaryFromData(filteredSalesData, isFiltered);
            totalVendasEl.textContent = summary.totalFaturamento.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            totalPesoEl.textContent = `${(summary.totalPeso / 1000).toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 })} Ton`;
            
            if (!tableView.classList.contains('hidden')) renderTable(filteredTableData);
            
            if (!chartView.classList.contains('hidden')) {
                updateTrendChart(filteredSalesData, filteredHistoryData);
                const totalForPercentage = supervisor ? Object.values(summary.vendasPorVendedor).reduce((a, b) => a + b, 0) : Object.values(summary.vendasPorSupervisor).reduce((a, b) => a + b, 0);
                const personChartTooltipOptions = { plugins: { tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) label += ': '; const value = context.parsed.y; if (value !== null) { label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value); if (totalForPercentage > 0) { const percentage = ((value / totalForPercentage) * 100).toFixed(2); label += ` (${percentage}%)`; } } return label; } } } } };
                if (supervisor) {
                    salesByPersonTitle.textContent = 'Vendas por Vendedor';
                    createChart('salesByPersonChart', 'bar', Object.keys(summary.vendasPorVendedor).map(getFirstName), Object.values(summary.vendasPorVendedor), personChartTooltipOptions);
                } else {
                    salesByPersonTitle.textContent = 'Vendas por Supervisor';
                    createChart('salesByPersonChart', 'bar', Object.keys(summary.vendasPorSupervisor), Object.values(summary.vendasPorSupervisor), personChartTooltipOptions);
                }
                
                document.getElementById('faturamentoPorFornecedorTitle').textContent = isFiltered ? 'Faturamento por Fornecedor' : 'Faturamento por Categoria';
                const faturamentoPorFornecedorData = summary.faturamentoPorFornecedor;
                const totalFaturamentoFornecedor = Object.values(faturamentoPorFornecedorData).reduce((a, b) => a + b, 0);
                const fornecedorTooltipOptions = { indexAxis: 'y', plugins: { tooltip: { callbacks: { label: function(context) { let label = context.label || ''; if (label) label += ': '; const value = context.parsed.x; if (value !== null) { label += new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value); if (totalFaturamentoFornecedor > 0) { const percentage = ((value / totalFaturamentoFornecedor) * 100).toFixed(2); label += ` (${percentage}%)`; } } return label; } } } } };
                const sortedFornecedores = Object.entries(faturamentoPorFornecedorData).sort(([, a], [, b]) => a - b); 
                if (sortedFornecedores.length > 0) createChart('faturamentoPorFornecedorChart', 'bar', sortedFornecedores.map(([name]) => name), sortedFornecedores.map(([, total]) => total), fornecedorTooltipOptions);
                else showNoDataMessage('faturamentoPorFornecedorChart', 'Sem dados de faturamento.');
                updateProductBarChart(summary);
            }
        }
        
        function populateSupervisors(filterElementId, dataSource) {
            const supervisorFilterEl = document.getElementById(filterElementId);
            const supervisors = [...new Set(dataSource.map(item => item.SUPERV).filter(Boolean))].sort();
            const currentSupervisorValue = supervisorFilterEl.value;
            supervisorFilterEl.innerHTML = '<option value="">Todos</option>';
            supervisors.forEach(sup => { supervisorFilterEl.innerHTML += `<option value="${sup}">${sup}</option>`; });
            if (supervisors.includes(currentSupervisorValue)) supervisorFilterEl.value = currentSupervisorValue;
            else supervisorFilterEl.value = '';
        }

        function updateSellerFilter(supervisor, dropdown, filterText, selectedArray, dataSource) {
            const sellersToShow = supervisor ? [...new Set(dataSource.filter(s => s.SUPERV === supervisor).map(s => s.NOME))].sort() : [...new Set(dataSource.map(item => item.NOME).filter(Boolean))].sort();
            selectedArray = selectedArray.filter(seller => sellersToShow.includes(seller));
            dropdown.innerHTML = '';
            sellersToShow.forEach(s => { const isChecked = selectedArray.includes(s); dropdown.innerHTML += `<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${s}" ${isChecked ? 'checked' : ''}><span class="ml-2">${s}</span></label>`; });
            if (selectedArray.length === 0 || selectedArray.length === sellersToShow.length) filterText.textContent = 'Todos Vendedores';
            else if (selectedArray.length === 1) filterText.textContent = selectedArray[0];
            else filterText.textContent = `${selectedArray.length} vendedores selecionados`;
            return selectedArray;
        }
        
        function updateRedeFilter(dropdown, buttonTextElement, selectedArray, dataSource, baseText = 'Com Rede') {
            const redesToShow = [...new Set(dataSource.map(item => item.ramo).filter(r => r && r !== 'N/A'))].sort();
            const validSelected = selectedArray.filter(rede => redesToShow.includes(rede));
            
            dropdown.innerHTML = '';
            redesToShow.forEach(r => { 
                const isChecked = validSelected.includes(r); 
                dropdown.innerHTML += `<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${r}" ${isChecked ? 'checked' : ''}><span class="ml-2 text-sm">${r}</span></label>`; 
            });

            if (validSelected.length === 0) {
                buttonTextElement.textContent = baseText;
            } else {
                buttonTextElement.textContent = `${baseText} (${validSelected.length})`;
            }
            return validSelected;
        }

        function resetMainFilters() {
            supervisorFilter.value = ''; 
            posicaoFilter.value = ''; 
            codcliFilter.value = ''; 
            currentFornecedor = ''; 
            selectedSellers = [];
            mainRedeGroupFilter = '';
            selectedMainRedes = [];

            mainRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            mainRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
            
            document.querySelectorAll('#fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));
            populateSupervisors('supervisor-filter', allSalesData);
            selectedSellers = updateSellerFilter('', vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
            updateAllVisuals();
        }
        
        function resetCityFilters() {
            citySupervisorFilter.value = ''; 
            cityNameFilter.value = ''; 
            cityCodCliFilter.value = ''; 
            selectedCitySellers = [];
            selectedCityRedes = [];
            cityRedeGroupFilter = '';
            
            selectedCitySellers = updateSellerFilter('', cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData);
            
            cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            cityRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData);

            updateCityView();
        }

        function resetWeeklyFilters() {
            weeklySupervisorFilter.querySelectorAll('input:checked').forEach(cb => cb.checked = false);
            currentWeeklyFornecedor = '';
            document.querySelectorAll('#weekly-fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));
            updateWeeklyView();
        }
        
        function resetComparisonFilters() {
            comparisonSupervisorFilter.value = ''; 
            currentComparisonFornecedor = ''; 
            comparisonCityFilter.value = ''; 
            filialFilter.value = 'ambas';
            selectedComparisonSellers = [];
            selectedComparisonSuppliers = [];
            selectedComparisonProducts = [];
            comparisonRedeGroupFilter = '';
            selectedComparisonRedes = [];
            
            comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            comparisonRedeGroupContainer.querySelector('button[data-group=""]').classList.add('active');
            updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);

            document.querySelectorAll('#comparison-fornecedor-toggle-container .fornecedor-btn').forEach(b => b.classList.remove('active'));

            updateAllComparisonFilters();
            updateComparisonView();
        }

        // NOVA FUNÇÃO PARA RESETAR FILTROS DE ESTOQUE
        function resetStockFilters() {
            stockFilialFilter.value = 'ambas';
            selectedStockSuppliers = [];
            selectedStockProducts = [];
            updateStockSupplierFilter();
            updateStockProductFilter();
            updateStockView();
        }


        function getRelevantClientsForCityFilter() {
            let clients = [...allClientsData];

            if (cityRedeGroupFilter === 'com_rede') {
                clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                if (selectedCityRedes.length > 0) {
                    clients = clients.filter(c => selectedCityRedes.includes(c.ramo));
                }
            } else if (cityRedeGroupFilter === 'sem_rede') {
                clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
            }

            const supervisor = citySupervisorFilter.value;
            if (supervisor) {
                const rcasOfSupervisor = [...new Set(allSalesData.filter(s => s.SUPERV === supervisor).map(s => s.CODUSUR))];
                clients = clients.filter(c => c.rcas.some(rca => rcasOfSupervisor.includes(rca)));
            }
            if (selectedCitySellers.length > 0) {
                const rcasOfVendedor = [...new Set(allSalesData.filter(s => selectedCitySellers.includes(s.NOME)).map(s => s.CODUSUR))];
                clients = clients.filter(c => c.rcas.some(rca => rcasOfVendedor.includes(rca)));
            }
            
            return clients;
        }
        
        function updateCitySuggestions(filterInput, suggestionsContainer, clientDataSource) {
            const inputValue = filterInput.value.toLowerCase();
            const allAvailableCities = [...new Set(clientDataSource.map(c => c.cidade).filter(c => c && c !== 'N/A'))].sort();
            const filteredCities = inputValue ? allAvailableCities.filter(c => c.toLowerCase().includes(inputValue)) : allAvailableCities;
            if (filteredCities.length > 0 && (document.activeElement === filterInput || !suggestionsContainer.classList.contains('manual-hide'))) {
                suggestionsContainer.innerHTML = filteredCities.map(c => `<div class="p-2 hover:bg-slate-600 cursor-pointer">${c}</div>`).join('');
                suggestionsContainer.classList.remove('hidden');
            } else suggestionsContainer.classList.add('hidden');
        }

        function validateCityFilter() {
            const selectedCity = cityNameFilter.value;
            if (!selectedCity) return; 
            const relevantClients = getRelevantClientsForCityFilter();
            const availableCities = [...new Set(relevantClients.map(c => c.cidade).filter(Boolean))];
            if (!availableCities.includes(selectedCity)) cityNameFilter.value = ''; 
        }

        function updateCityView() {
            const supervisor = citySupervisorFilter.value;
            const codcliFilterVal = cityCodCliFilter.value.trim();
            if (codcliFilterVal && !allClientsData.some(c => String(c['Código']) === codcliFilterVal)) return;
            let clientsForAnalysis = getRelevantClientsForCityFilter();
            const allAvailableCities = [...new Set(clientsForAnalysis.map(c => c.cidade).filter(Boolean))];
            const cidadeFiltroInput = cityNameFilter.value.trim();
            let cidadeFiltro = '';
            if (cidadeFiltroInput && allAvailableCities.includes(cidadeFiltroInput)) cidadeFiltro = cidadeFiltroInput;
            
            const referenceDate = lastSaleDate;
            const currentMonth = referenceDate.getMonth();
            const currentYear = referenceDate.getFullYear();
            
            let salesForAnalysis = allSalesData;
            
            const clientCodesForAnalysis = new Set(clientsForAnalysis.map(c => c['Código']));
            salesForAnalysis = salesForAnalysis.filter(s => clientCodesForAnalysis.has(s.CODCLI));

            if (supervisor) salesForAnalysis = salesForAnalysis.filter(s => s.SUPERV === supervisor);
            if (selectedCitySellers.length > 0) salesForAnalysis = salesForAnalysis.filter(s => selectedCitySellers.includes(s.NOME));
            
            if (cidadeFiltro) { clientsForAnalysis = clientsForAnalysis.filter(c => c.cidade && c.cidade === cidadeFiltro); salesForAnalysis = salesForAnalysis.filter(s => s.CIDADE && s.CIDADE === cidadeFiltro); }
            if (codcliFilterVal) { clientsForAnalysis = clientsForAnalysis.filter(c => String(c['Código']) === codcliFilterVal); salesForAnalysis = salesForAnalysis.filter(s => s.CODCLI === codcliFilterVal); }
            
            const salesThisMonth = allSalesData.filter(sale => {
                const saleDate = parseDate(sale.DTPED);
                return saleDate && saleDate.getFullYear() === currentYear && saleDate.getMonth() === currentMonth;
            });

            const clientTotalsThisMonth = new Map();
            salesThisMonth.forEach(sale => {
                const codcli = sale.CODCLI;
                const currentTotal = clientTotalsThisMonth.get(codcli) || 0;
                clientTotalsThisMonth.set(codcli, currentTotal + sale.VLVENDA);
            });

            let activeClientsList = [];
            let inactiveClientsList = [];

            clientsForAnalysis.forEach(client => {
                const codcli = String(client['Código']);
                if (codcli === '6720' || client.bloqueio === 'S') return;

                const registrationDate = parseDate(client.dataCadastro);
                client.isNew = registrationDate && registrationDate.getMonth() === currentMonth && registrationDate.getFullYear() === currentYear;

                const totalFaturamentoMes = clientTotalsThisMonth.get(codcli) || 0;

                if (totalFaturamentoMes > 0) {
                    activeClientsList.push(client);
                } else {
                    if (totalFaturamentoMes < 0) {
                        client.isReturn = true;
                    }
                    const clientRcas = client.rcas || [];
                    if (clientRcas.length > 0 && clientRcas.every(rca => rca === '53')) return;
                    client.isNewForInactiveLabel = client.isNew && !parseDate(client.ultimaCompra);
                    inactiveClientsList.push(client);
                }
            });
            
            inactiveClientsForExport = inactiveClientsList;

            if (clientsForAnalysis.length > 0) {
                 const statusChartOptions = { animation: { duration: 800, easing: 'easeOutQuart' }, plugins: { legend: { position: 'bottom', labels: { color: '#cbd5e1' } }, tooltip: { callbacks: { label: function(context) { return context.label; } } }, datalabels: { formatter: (value, ctx) => { const total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0); if (total === 0 || value === 0) return ''; const percentage = (value * 100 / total).toFixed(1) + "%"; return `${value}\n(${percentage})`; }, color: '#fff', font: { weight: 'bold' }, textAlign: 'center' } } };
                createChart('customerStatusChart', 'doughnut', ['Ativos no Mês', 'S/ Vendas no Mês'], [activeClientsList.length, inactiveClientsList.length], statusChartOptions);
            } else showNoDataMessage('customerStatusChart', 'Sem clientes no filtro para exibir o status.');
            
            const salesByActiveClient = {};
            activeClientsList.forEach(client => {
                const codcli = String(client['Código']);
                let clientSales = salesThisMonth.filter(s => s.CODCLI === codcli);
                
                if (selectedCitySellers.length > 0) {
                    clientSales = clientSales.filter(s => selectedCitySellers.includes(s.NOME));
                }

                const totalFaturamentoFiltrado = clientSales.reduce((sum, s) => sum + s.VLVENDA, 0);

                if (totalFaturamentoFiltrado > 0) {
                    const pepsicoTotal = clientSales.filter(s => s.OBSERVACAOFOR === 'PEPSICO').reduce((sum, s) => sum + s.VLVENDA, 0);
                    const multimarcasTotal = clientSales.filter(s => s.OBSERVACAOFOR === 'MULTIMARCAS').reduce((sum, s) => sum + s.VLVENDA, 0);
                    const outrosTotal = totalFaturamentoFiltrado - pepsicoTotal - multimarcasTotal;
                    salesByActiveClient[codcli] = { ...client, total: totalFaturamentoFiltrado, pepsico: pepsicoTotal, multimarcas: multimarcasTotal, outros: outrosTotal };
                }
            });
            
            const sortedActiveClients = Object.values(salesByActiveClient).sort((a, b) => b.total - a.total);
            activeClientsForExport = sortedActiveClients;
            cityActiveDetailTableBody.innerHTML = sortedActiveClients.map(data => { 
                const novoLabel = data.isNew ? `<span class="ml-2 text-xs font-semibold text-purple-400 bg-purple-900/50 px-2 py-0.5 rounded-full">NOVO</span>` : ''; 
                let tooltipParts = []; 
                if (data.pepsico > 0) tooltipParts.push(`PEPSICO: ${data.pepsico.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`); 
                if (data.multimarcas > 0) tooltipParts.push(`MULTIMARCAS: ${data.multimarcas.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`); 
                if (data.outros > 0.001) tooltipParts.push(`OUTROS: ${data.outros.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}`);
                const tooltipText = tooltipParts.length > 0 ? tooltipParts.join('<br>') : 'Sem detalhamento de categoria';
                return `<tr class="hover:bg-slate-700"><td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${data['Código']}">${data['Código']}</a></td><td class="px-4 py-2 flex items-center">${data.fantasia || data.razaoSocial}${novoLabel}</td><td class="px-4 py-2 text-right"><div class="tooltip">${data.total.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<span class="tooltip-text" style="width: max-content; transform: translateX(-50%); margin-left: 0;">${tooltipText}</span></div></td><td class="px-4 py-2">${data.cidade}</td><td class="px-4 py-2">${data.bairro}</td><td class="px-4 py-2">${data.rcas[0] || '-'}</td><td class="px-4 py-2">${data.rcas[1] || '-'}</td></tr>` 
            }).join('');
            
            inactiveClientsList.sort((a, b) => { 
                if (a.isReturn && !b.isReturn) return -1;
                if (!a.isReturn && b.isReturn) return 1;
                if (a.isNewForInactiveLabel && !b.isNewForInactiveLabel) return -1; 
                if (!a.isNewForInactiveLabel && b.isNewForInactiveLabel) return 1; 
                return (parseDate(b.ultimaCompra) || 0) - (parseDate(a.ultimaCompra) || 0); 
            });
            cityInactiveDetailTableBody.innerHTML = inactiveClientsList.map(client => { 
                const novoLabel = client.isNewForInactiveLabel ? `<span class="ml-2 text-xs font-semibold text-purple-400 bg-purple-900/50 px-2 py-0.5 rounded-full">NOVO</span>` : ''; 
                const devolucaoLabel = client.isReturn ? `<span class="ml-2 text-xs font-semibold text-red-400 bg-red-900/50 px-2 py-0.5 rounded-full">DEVOLUÇÃO</span>` : '';
                return `<tr class="hover:bg-slate-700"><td class="px-4 py-2"><a href="#" class="text-teal-400 hover:underline" data-codcli="${client['Código']}">${client['Código']}</a></td><td class="px-4 py-2 flex items-center">${client.fantasia || client.razaoSocial}${novoLabel}${devolucaoLabel}</td><td class="px-4 py-2">${client.cidade}</td><td class="px-4 py-2">${client.bairro}</td><td class="px-4 py-2 text-center">${formatDate(client.ultimaCompra)}</td><td class="px-4 py-2">${client.rcas[0] || '-'}</td><td class="px-4 py-2">${client.rcas[1] || '-'}</td></tr>` 
            }).join('');
            
            const cityChartTitleEl = document.getElementById('city-chart-title');
            const cityChartOptions = { indexAxis: 'y', scales: { x: { grace: '15%' } }, plugins: { datalabels: { align: 'end', anchor: 'end', color: '#cbd5e1', font: { size: 14, weight: 'bold' }, formatter: (value) => (value / 1000).toFixed(1) + 'k', offset: 8 } } };
            const totalFaturamentoCidade = salesForAnalysis.reduce((sum, item) => sum + item.VLVENDA, 0);
            totalFaturamentoCidadeEl.textContent = totalFaturamentoCidade.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            if (cidadeFiltro) {
                cityChartTitleEl.textContent = 'Top 10 Bairros';
                const salesByBairro = {};
                salesForAnalysis.forEach(sale => { const bairro = sale.BAIRRO || 'N/A'; salesByBairro[bairro] = (salesByBairro[bairro] || 0) + sale.VLVENDA; });
                const sortedBairros = Object.entries(salesByBairro).sort(([, a], [, b]) => b - a).slice(0, 10);
                createChart('salesByClientInCityChart', 'bar', sortedBairros.map(([name]) => name), sortedBairros.map(([, total]) => total), cityChartOptions);
            } else {
                cityChartTitleEl.textContent = 'Top 10 Cidades';
                const salesByCity = {};
                salesForAnalysis.forEach(sale => { const cidade = sale.CIDADE || 'N/A'; salesByCity[cidade] = (salesByCity[cidade] || 0) + sale.VLVENDA; });
                const sortedCidades = Object.entries(salesByCity).sort(([, a], [, b]) => b - a).slice(0, 10);
                createChart('salesByClientInCityChart', 'bar', sortedCidades.map(([name]) => name), sortedCidades.map(([, total]) => total), cityChartOptions);
            }
        }
        
        function getWeekOfMonth(date) { 
            const d = new Date(date);
            const startOfMonth = new Date(d.getFullYear(), d.getMonth(), 1);
            const dayOfMonth = d.getDate();
            const dayOfWeek = startOfMonth.getDay();
            const adjustedDayOfWeek = (dayOfWeek === 0) ? 6 : dayOfWeek - 1;
            return Math.ceil((dayOfMonth + adjustedDayOfWeek) / 7);
        }

        function calculateHistoricalBests() {
            const salesBySupervisorByDay = {};
            const mostRecentSaleDate = allSalesData.map(s => parseDate(s.DTPED)).filter(Boolean).reduce((a, b) => a > b ? a : b, new Date(0));
            const previousMonthDate = new Date(mostRecentSaleDate.getFullYear(), mostRecentSaleDate.getMonth() - 1, 1);
            const previousMonth = previousMonthDate.getMonth();
            const previousMonthYear = previousMonthDate.getFullYear();
            const historyLastMonthData = allHistoryData.filter(sale => { const saleDate = parseDate(sale.DTPED); return saleDate && saleDate.getMonth() === previousMonth && saleDate.getFullYear() === previousMonthYear; });
            historyLastMonthData.forEach(sale => {
                if (!sale.SUPERV || sale.SUPERV === 'BALCAO' || !sale.DTPED) return;
                const saleDate = parseDate(sale.DTPED); if (!saleDate) return;
                const supervisor = sale.SUPERV.toUpperCase(); const dateString = saleDate.toISOString().split('T')[0];
                if (!salesBySupervisorByDay[supervisor]) salesBySupervisorByDay[supervisor] = {};
                if (!salesBySupervisorByDay[supervisor][dateString]) salesBySupervisorByDay[supervisor][dateString] = 0;
                salesBySupervisorByDay[supervisor][dateString] += sale.VLVENDA;
            });
            const bestDayByWeekdayBySupervisor = {};
            for (const supervisor in salesBySupervisorByDay) {
                const salesByDay = salesBySupervisorByDay[supervisor];
                const bests = {};
                for (const dateString in salesByDay) {
                    const date = new Date(dateString + 'T00:00:00');
                    const dayOfWeek = date.getDay();
                    const total = salesByDay[dateString];
                    if (dayOfWeek >= 1 && dayOfWeek <= 5) { if (!bests[dayOfWeek] || total > bests[dayOfWeek]) bests[dayOfWeek] = total; }
                }
                bestDayByWeekdayBySupervisor[supervisor] = bests;
            }
            historicalBests = bestDayByWeekdayBySupervisor;
        }

        function populateWeeklyFilters() {
            const supervisors = [...new Set(allSalesData.map(item => item.SUPERV).filter(Boolean).filter(sup => sup !== 'BALCAO'))].sort();
            weeklySupervisorFilter.innerHTML = '';
            supervisors.forEach(sup => { weeklySupervisorFilter.innerHTML += `<div class="flex items-center"><input id="sup-check-${sup.replace(/\s+/g, '-')}" type="checkbox" value="${sup}" class="w-4 h-4 text-teal-600 bg-slate-700 border-slate-600 rounded focus:ring-teal-600 ring-offset-slate-800 focus:ring-2"><label for="sup-check-${sup.replace(/\s+/g, '-')}" class="ml-2 text-sm font-medium text-slate-300">${sup}</label></div>`; });
        }

        function updateWeeklyView() {
            const selectedSupervisors = Array.from(weeklySupervisorFilter.querySelectorAll('input:checked')).map(cb => cb.value);
            let dataForGeneralCharts = allSalesData;
            if (currentWeeklyFornecedor) dataForGeneralCharts = dataForGeneralCharts.filter(row => String(row.OBSERVACAOFOR).trim() === currentWeeklyFornecedor);
            if (selectedSupervisors.length > 0) dataForGeneralCharts = dataForGeneralCharts.filter(d => selectedSupervisors.includes(d.SUPERV));
            const currentMonth = lastSaleDate.getMonth(); const currentYear = lastSaleDate.getFullYear();
            const monthSales = dataForGeneralCharts.filter(d => { if (!d.DTPED) return false; const saleDate = parseDate(d.DTPED); return saleDate && saleDate.getMonth() === currentMonth && saleDate.getFullYear() === currentYear; });
            const totalMes = monthSales.reduce((sum, item) => sum + item.VLVENDA, 0);
            totalMesSemanalEl.textContent = totalMes.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
            const salesByWeekAndDay = {}; const dayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            monthSales.forEach(sale => { const saleDate = parseDate(sale.DTPED); if (!saleDate) return; const weekNum = getWeekOfMonth(saleDate); const dayName = dayNames[saleDate.getDay()]; if (!salesByWeekAndDay[weekNum]) salesByWeekAndDay[weekNum] = {}; if (!salesByWeekAndDay[weekNum][dayName]) salesByWeekAndDay[weekNum][dayName] = 0; salesByWeekAndDay[weekNum][dayName] += sale.VLVENDA; });
            const weekLabels = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta'];
            const weekNumbers = Object.keys(salesByWeekAndDay).sort((a,b) => a - b);
            const professionalPalette = ['#14b8a6', '#6366f1', '#ec4899', '#f97316', '#8b5cf6'];
            const currentMonthDatasets = weekNumbers.map((weekNum, index) => ({ label: `Semana ${weekNum}`, data: weekLabels.map(day => salesByWeekAndDay[weekNum][day] || 0), backgroundColor: professionalPalette[index % professionalPalette.length] }));
            const supervisorsForHistory = selectedSupervisors.length > 0 ? selectedSupervisors : Object.keys(historicalBests).map(s => s.toLowerCase().replace(/(?:^|\s)\S/g, a => a.toUpperCase()));
            const historicalDataForChart = [0, 0, 0, 0, 0];
            supervisorsForHistory.forEach(sup => { const bests = historicalBests[sup.toUpperCase()]; if(bests) { historicalDataForChart[0] += bests[1] || 0; historicalDataForChart[1] += bests[2] || 0; historicalDataForChart[2] += bests[3] || 0; historicalDataForChart[3] += bests[4] || 0; historicalDataForChart[4] += bests[5] || 0; } });
            const historicalDataset = { type: 'line', label: 'Melhor Dia Mês Anterior', data: historicalDataForChart, borderColor: '#f59e0b', backgroundColor: 'transparent', pointBackgroundColor: '#f59e0b', pointRadius: 4, tension: 0.1, borderWidth: 2, yAxisID: 'y', datalabels: { display: false } };
            const finalDatasets = [...currentMonthDatasets, historicalDataset];
            const weeklyChartOptions = { plugins: { legend: { display: true, onClick: (e, legendItem, legend) => { const index = legendItem.datasetIndex; const ci = legend.chart; if (ci.isDatasetVisible(index)) { ci.hide(index); legendItem.hidden = true; } else { ci.show(index); legendItem.hidden = false; } let newTotal = 0; ci.data.datasets.forEach((dataset, i) => { if (ci.isDatasetVisible(i) && dataset.type !== 'line') newTotal += dataset.data.reduce((acc, val) => acc + val, 0); }); totalMesSemanalEl.textContent = newTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }); } } } };
            createChart('weeklySalesChart', 'bar', weekLabels, finalDatasets, weeklyChartOptions);
            const weeklySummaryTableBody = document.getElementById('weekly-summary-table-body');
            if (weeklySummaryTableBody) {
                weeklySummaryTableBody.innerHTML = ''; let grandTotal = 0;
                Object.keys(salesByWeekAndDay).sort((a,b) => parseInt(a) - parseInt(b)).forEach(weekNum => { const weekTotal = Object.values(salesByWeekAndDay[weekNum]).reduce((a, b) => a + b, 0); grandTotal += weekTotal; weeklySummaryTableBody.innerHTML += `<tr class="hover:bg-slate-700"><td class="px-4 py-2">Semana ${weekNum}</td><td class="px-4 py-2 text-right">${weekTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td></tr>`; });
                weeklySummaryTableBody.innerHTML += `<tr class="font-bold bg-slate-700/50"><td class="px-4 py-2">Total do Mês</td><td class="px-4 py-2 text-right">${grandTotal.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td></tr>`;
            }
            const dataForRankings = dataForGeneralCharts.filter(d => d.SUPERV !== 'BALCAO');
            const positivacao = {}; dataForRankings.forEach(d => { if (!d.NOME || !d.CODCLI) return; if (!positivacao[d.NOME]) positivacao[d.NOME] = new Set(); positivacao[d.NOME].add(d.CODCLI); });
            const positivacaoRank = Object.entries(positivacao).map(([v, c]) => ({ vendedor: v, total: c.size })).sort((a, b) => b.total - a.total).slice(0, 10);
            if (positivacaoRank.length > 0) createChart('positivacaoChart', 'bar', positivacaoRank.map(r => getFirstName(r.vendedor)), positivacaoRank.map(r => r.total));
            else showNoDataMessage('positivacaoChart', 'Sem dados para o ranking.');
            const salesBySeller = {}; dataForRankings.forEach(d => { if (!d.NOME) return; salesBySeller[d.NOME] = (salesBySeller[d.NOME] || 0) + d.VLVENDA; });
            const topSellersRank = Object.entries(salesBySeller).sort(([, a], [, b]) => b - a).slice(0, 10);
            if (topSellersRank.length > 0) createChart('topSellersChart', 'bar', topSellersRank.map(r => getFirstName(r[0])), topSellersRank.map(r => r[1]));
            else showNoDataMessage('topSellersChart', 'Sem dados para o ranking.');
            const vendorsInFilter = [...new Set(dataForRankings.map(d => d.NOME))].filter(v => v !== 'VD HIAGO');
            const mixRank = vendorsInFilter.map(vendedor => { const vendorSales = dataForRankings.filter(d => d.NOME === vendedor); if (vendorSales.length === 0) return { vendedor, avgMix: 0 }; const supervisor = vendorSales[0].SUPERV; let salesForMixCalc; if (supervisor === 'OSVALDO NUNES O') salesForMixCalc = vendorSales; else { const targetSuppliers = ['707', '708']; salesForMixCalc = vendorSales.filter(d => targetSuppliers.includes(String(d.CODFOR))); } const mixPerClient = {}; salesForMixCalc.forEach(d => { if (!d.CODCLI || !d.DESCRICAO) return; if (!mixPerClient[d.CODCLI]) mixPerClient[d.CODCLI] = new Set(); mixPerClient[d.CODCLI].add(d.DESCRICAO); }); const mixValues = Object.values(mixPerClient).map(p => p.size); if (mixValues.length === 0) return { vendedor, avgMix: 0 }; const avgMix = mixValues.reduce((a, b) => a + b, 0) / mixValues.length; return { vendedor, avgMix }; }).sort((a, b) => b.avgMix - a.avgMix).slice(0, 10);
            if(mixRank.length > 0 && mixRank.some(r => r.avgMix > 0)) createChart('mixChart', 'bar', mixRank.map(r => getFirstName(r.vendedor)), mixRank.map(r => r.avgMix));
            else showNoDataMessage('mixChart', 'Sem dados para o ranking.');
        }

        function updateSupplierFilter(dropdown, filterText, selectedArray, dataSource, filterType = 'comparison') {
            const suppliers = new Map();
            dataSource.forEach(s => { if(s.CODFOR && s.FORNECEDOR) suppliers.set(s.CODFOR, s.FORNECEDOR); });
            const sortedSuppliers = [...suppliers.entries()].sort((a, b) => a[1].localeCompare(b[1]));

            selectedArray = selectedArray.filter(cod => suppliers.has(cod));

            dropdown.innerHTML = '';
            sortedSuppliers.forEach(([cod, name]) => {
                const isChecked = selectedArray.includes(cod);
                dropdown.innerHTML += `<label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer"><input type="checkbox" data-filter-type="${filterType}" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${cod}" ${isChecked ? 'checked' : ''}><span class="ml-2 text-xs">${cod} - ${name}</span></label>`;
            });

            if (selectedArray.length === 0 || selectedArray.length === sortedSuppliers.length) {
                filterText.textContent = 'Todos Fornecedores';
            } else if (selectedArray.length === 1) {
                filterText.textContent = suppliers.get(selectedArray[0]) || '1 selecionado';
            } else {
                filterText.textContent = `${selectedArray.length} fornecedores selecionados`;
            }
            return selectedArray;
        }


        function updateComparisonCitySuggestions(dataSource) {
            const inputValue = comparisonCityFilter.value.toLowerCase();
            const allAvailableCities = [...new Set(dataSource.map(c => c.CIDADE).filter(c => c && c !== 'N/A'))].sort();
            const filteredCities = inputValue ? allAvailableCities.filter(c => c.toLowerCase().includes(inputValue)) : allAvailableCities;
            if (filteredCities.length > 0 && (document.activeElement === comparisonCityFilter || !comparisonCitySuggestions.classList.contains('manual-hide'))) {
                comparisonCitySuggestions.innerHTML = filteredCities.map(c => `<div class="p-2 hover:bg-slate-600 cursor-pointer">${c}</div>`).join('');
                comparisonCitySuggestions.classList.remove('hidden');
            } else {
                comparisonCitySuggestions.classList.add('hidden');
            }
        }
        
        function getPositiveClientsWithNewLogic(salesData, pasta) {
            const salesByClient = new Map();
            salesData.forEach(sale => {
                if (!sale.CODCLI) return;
                const clientTotal = salesByClient.get(sale.CODCLI) || 0;
                salesByClient.set(sale.CODCLI, clientTotal + sale.VLVENDA);
            });

            let positiveClients = 0;
            const threshold = pasta === 'PEPSICO' ? 50 : (pasta === 'MULTIMARCAS' ? 1 : 0);

            for (const total of salesByClient.values()) {
                if (total > threshold) {
                    positiveClients++;
                }
            }
            return positiveClients;
        }

        function getMonthlyPositiveClientsCountWithNewLogic(salesData, pasta) {
            const salesByMonthByClient = {};

            salesData.forEach(sale => {
                if (!sale.CODCLI) return;
                const saleDate = parseDate(sale.DTPED);
                if (saleDate) {
                    const monthKey = `${saleDate.getFullYear()}-${saleDate.getMonth()}`;
                    if (!salesByMonthByClient[monthKey]) {
                        salesByMonthByClient[monthKey] = new Map();
                    }
                    const clientSales = salesByMonthByClient[monthKey].get(sale.CODCLI) || 0;
                    salesByMonthByClient[monthKey].set(sale.CODCLI, clientSales + sale.VLVENDA);
                }
            });

            let totalPositiveClientsSum = 0;
            const threshold = pasta === 'PEPSICO' ? 50 : (pasta === 'MULTIMARCAS' ? 1 : 0);

            for (const monthKey in salesByMonthByClient) {
                const clientTotals = salesByMonthByClient[monthKey];
                let positiveClientsInMonth = 0;
                for (const total of clientTotals.values()) {
                    if (total > threshold) {
                        positiveClientsInMonth++;
                    }
                }
                totalPositiveClientsSum += positiveClientsInMonth;
            }

            return totalPositiveClientsSum;
        }

        function getSundayBasedWeeks(year, month) {
            const weeks = [];
            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);

            let startDate = new Date(firstDayOfMonth);
            startDate.setHours(0, 0, 0, 0);
            startDate.setDate(startDate.getDate() - startDate.getDay());

            while (startDate <= lastDayOfMonth) {
                let endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + 6);
                endDate.setHours(23, 59, 59, 999);
                weeks.push({ start: new Date(startDate), end: new Date(endDate) });
                startDate.setDate(startDate.getDate() + 7);
            }
            return weeks;
        }
        
        function normalize(str) {
            return str
                ? str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, '').toUpperCase()
                : '';
        }

        function calculateAverageMixComDevolucao(salesData, targetCodfors) {
            if (!salesData || salesData.length === 0 || !targetCodfors || targetCodfors.length === 0) return 0;
            const saldoPorClienteProduto = {};
            salesData.forEach(sale => {
                if (!targetCodfors.includes(String(sale.CODFOR))) return;
                if (!sale.CODCLI || !sale.PRODUTO || !sale.PEDIDO) return;
                const key = `${sale.CODCLI}_${sale.PRODUTO}_${sale.PEDIDO}`;
                saldoPorClienteProduto[key] = (saldoPorClienteProduto[key] || 0) + (Number(sale.QTVENDA) || 0);
            });
            const mixPerClient = {};
            Object.entries(saldoPorClienteProduto).forEach(([key, saldo]) => {
                if (saldo > 1) {
                    const [codcli, produto] = key.split('_');
                    if (!mixPerClient[codcli]) mixPerClient[codcli] = new Set();
                    mixPerClient[codcli].add(produto);
                }
            });
            const mixValues = Object.values(mixPerClient).map(set => set.size);
            if (mixValues.length === 0) return 0;
            return mixValues.reduce((a, b) => a + b, 0) / mixValues.length;
        }

        function calculatePositivacaoPorCestaComDevolucao(salesData, requiredCategories) {
            if (!salesData || salesData.length === 0 || !requiredCategories || requiredCategories.length === 0) return 0;
            const normalizedCategories = requiredCategories.map(normalize);
            const saldoPorClienteProduto = {};
            salesData.forEach(sale => {
                if (!sale.CODCLI || !sale.DESCRICAO || !sale.PRODUTO || !sale.PEDIDO) return;
                const key = `${sale.CODCLI}_${sale.PRODUTO}_${sale.PEDIDO}`;
                saldoPorClienteProduto[key] = (saldoPorClienteProduto[key] || 0) + (Number(sale.QTVENDA) || 0);
            });
            const clientPurchases = new Map();
            Object.entries(saldoPorClienteProduto).forEach(([key, saldo]) => {
                if (saldo > 1) {
                    const [codcli, produto, pedido] = key.split('_');
                    const sale = salesData.find(s => String(s.CODCLI) === codcli && String(s.PRODUTO) === produto && String(s.PEDIDO) === pedido);
                    if (sale) {
                        const description = normalize(sale.DESCRICAO);
                        normalizedCategories.forEach(category => {
                            if (description.includes(category)) {
                                if (!clientPurchases.has(codcli)) {
                                    clientPurchases.set(codcli, new Set());
                                }
                                clientPurchases.get(codcli).add(category);
                            }
                        });
                    }
                }
            });
            let positivadosCount = 0;
            const requiredCategoryCount = normalizedCategories.length;
            for (const categoriesPurchased of clientPurchases.values()) {
                if (categoriesPurchased.size === requiredCategoryCount) {
                    positivadosCount++;
                }
            }
            return positivadosCount;
        }

        function groupSalesByMonth(salesData) {
            const salesByMonth = {};
            salesData.forEach(sale => {
                const date = parseDate(sale.DTPED);
                if (!date || isNaN(date.getTime())) return;
                const monthKey = date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0');
                if (!salesByMonth[monthKey]) salesByMonth[monthKey] = [];
                salesByMonth[monthKey].push(sale);
            });
            return salesByMonth;
        }
        function monthlyKpiAverage(historySales, kpiFn, ...kpiArgs) {
            const salesByMonth = groupSalesByMonth(historySales);
            const kpiValues = Object.values(salesByMonth).map(sales => kpiFn(sales, ...kpiArgs));
            if (kpiValues.length === 0) return 0;
            return kpiValues.reduce((a, b) => a + b, 0) / kpiValues.length;
        }
        
        function getComparisonFilteredData(options = {}) {
            const { excludeFilter = null } = options;
            
            let clients = [...allClientsData];
            if (comparisonRedeGroupFilter === 'com_rede') {
                clients = clients.filter(c => c.ramo && c.ramo !== 'N/A');
                 if (selectedComparisonRedes.length > 0) {
                    clients = clients.filter(c => selectedComparisonRedes.includes(c.ramo));
                }
            } else if (comparisonRedeGroupFilter === 'sem_rede') {
                clients = clients.filter(c => !c.ramo || c.ramo === 'N/A');
            }
            const clientCodes = new Set(clients.map(c => c['Código']));

            const supervisor = comparisonSupervisorFilter.value;
            const sellers = selectedComparisonSellers;
            const suppliers = selectedComparisonSuppliers;
            const products = selectedComparisonProducts;
            const pasta = currentComparisonFornecedor;
            const city = comparisonCityFilter.value.trim();

            const filterFunction = s => 
                (clientCodes.has(s.CODCLI)) &&
                (excludeFilter === 'supervisor' || !supervisor || s.SUPERV === supervisor) &&
                (excludeFilter === 'seller' || sellers.length === 0 || sellers.includes(s.NOME)) &&
                (excludeFilter === 'supplier' || suppliers.length === 0 || suppliers.includes(String(s.CODFOR))) &&
                (excludeFilter === 'product' || products.length === 0 || products.includes(String(s.PRODUTO))) &&
                (excludeFilter === 'pasta' || !pasta || s.OBSERVACAOFOR === pasta) &&
                (excludeFilter === 'city' || !city || (s.CIDADE && s.CIDADE.toLowerCase() === city.toLowerCase()));

            return {
                currentSales: allSalesData.filter(filterFunction),
                historySales: allHistoryData.filter(filterFunction)
            };
        }


        function updateAllComparisonFilters() {
            const supervisorOptionsData = getComparisonFilteredData({ excludeFilter: 'supervisor' }).historySales;
            const currentSupervisor = comparisonSupervisorFilter.value;
            populateSupervisors('comparison-supervisor-filter', supervisorOptionsData);
            if ([...comparisonSupervisorFilter.options].some(o => o.value === currentSupervisor)) {
                comparisonSupervisorFilter.value = currentSupervisor;
            }

            const sellerOptionsData = getComparisonFilteredData({ excludeFilter: 'seller' }).historySales;
            selectedComparisonSellers = updateSellerFilter(comparisonSupervisorFilter.value, comparisonVendedorFilterDropdown, comparisonVendedorFilterText, selectedComparisonSellers, sellerOptionsData);

            const supplierOptionsData = getComparisonFilteredData({ excludeFilter: 'supplier' }).historySales;
            selectedComparisonSuppliers = updateSupplierFilter(comparisonSupplierFilterDropdown, comparisonSupplierFilterText, selectedComparisonSuppliers, supplierOptionsData, 'comparison');
            
            updateComparisonProductFilter();

            const cityOptionsData = getComparisonFilteredData({ excludeFilter: 'city' }).historySales;
            updateComparisonCitySuggestions(cityOptionsData);

            const pastaOptionsData = getComparisonFilteredData({ excludeFilter: 'pasta' }).historySales;
            const pepsicoBtn = document.querySelector('#comparison-fornecedor-toggle-container button[data-fornecedor="PEPSICO"]');
            const multimarcasBtn = document.querySelector('#comparison-fornecedor-toggle-container button[data-fornecedor="MULTIMARCAS"]');
            const hasPepsico = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'PEPSICO');
            const hasMultimarcas = pastaOptionsData.some(s => s.OBSERVACAOFOR === 'MULTIMARCAS');
            pepsicoBtn.disabled = !hasPepsico;
            multimarcasBtn.disabled = !hasMultimarcas;
            pepsicoBtn.classList.toggle('opacity-50', !hasPepsico);
            multimarcasBtn.classList.toggle('opacity-50', !hasMultimarcas);
        }

        function updateProductFilter(dropdown, filterText, selectedArray, dataSource, filterType = 'comparison') {
            const searchInput = dropdown.querySelector('input[type="text"]');
            const listContainer = dropdown.querySelector('div[id$="-list"]');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

            const products = [...new Map(dataSource.map(s => [s.PRODUTO, s.DESCRICAO])).entries()].sort((a,b) => a[1].localeCompare(b[1]));

            const filteredProducts = searchTerm.length > 0 
                ? products.filter(([code, name]) =>
                    name.toLowerCase().includes(searchTerm) || code.toLowerCase().includes(searchTerm)
                  )
                : products;

            listContainer.innerHTML = '';
            filteredProducts.forEach(([code, name]) => {
                const isChecked = selectedArray.includes(code);
                listContainer.innerHTML += `
                    <label class="flex items-center p-2 hover:bg-slate-600 cursor-pointer">
                        <input type="checkbox" data-filter-type="${filterType}" class="form-checkbox h-4 w-4 bg-slate-800 border-slate-500 rounded text-teal-500 focus:ring-teal-500" value="${code}" ${isChecked ? 'checked' : ''}>
                        <span class="ml-2 text-xs">(${code}) ${name}</span>
                    </label>`;
            });

            if (selectedArray.length === 0) {
                filterText.textContent = 'Todos os Produtos';
            } else if (selectedArray.length === 1) {
                const productsInfo = new Map(products);
                filterText.textContent = productsInfo.get(selectedArray[0]) || '1 selecionado';
            } else {
                filterText.textContent = `${selectedArray.length} produtos selecionados`;
            }
        }
        
        function updateComparisonProductFilter() {
             updateProductFilter(comparisonProductFilterDropdown, comparisonProductFilterText, selectedComparisonProducts, getComparisonFilteredData({ excludeFilter: 'product' }).historySales, 'comparison');
        }
        
        function updateStockProductFilter() {
             updateProductFilter(stockProductFilterDropdown, stockProductFilterText, selectedStockProducts, allSalesData, 'stock');
        }

        function updateStockSupplierFilter() {
            selectedStockSuppliers = updateSupplierFilter(stockSupplierFilterDropdown, stockSupplierFilterText, selectedStockSuppliers, allSalesData, 'stock');
        }


        function getActiveStockMap(filial) {
            const filterValue = filial || filialFilter.value;
            if (filterValue === '05') {
                return stockData05;
            }
            if (filterValue === '08') {
                return stockData08;
            }
            const combinedStock = new Map(stockData05);
            stockData08.forEach((qty, code) => {
                combinedStock.set(code, (combinedStock.get(code) || 0) + qty);
            });
            return combinedStock;
        }

        function updateComparisonView() {
            const filteredData = getComparisonFilteredData();
            const { currentSales, historySales } = filteredData;
            
            const historyTotalFat = historySales.reduce((sum, item) => sum + item.VLVENDA, 0);
            const currentTotalFat = currentSales.reduce((sum, item) => sum + item.VLVENDA, 0);
            const historyTotalPeso = historySales.reduce((sum, item) => sum + item.TOTPESOLIQ, 0);
            const currentTotalPeso = currentSales.reduce((sum, item) => sum + item.TOTPESOLIQ, 0);
            
            const pasta = currentComparisonFornecedor;
            const currentClients = getPositiveClientsWithNewLogic(currentSales, pasta);
            const historyClientsTotalPerMonthSum = getMonthlyPositiveClientsCountWithNewLogic(historySales, pasta);

            const historyMonthsCount = getUniqueMonthCount(historySales);
            const historyClientsAverage = historyMonthsCount > 0 ? historyClientsTotalPerMonthSum / historyMonthsCount : 0;
            
            const currentTicket = currentClients > 0 ? currentTotalFat / currentClients : 0;
            const historyTicketAverage = historyClientsTotalPerMonthSum > 0 ? historyTotalFat / historyClientsTotalPerMonthSum : 0;
            
            const pepsicoCodfors = ['707', '708'];
            const saltyCategories = ['CHEETOS', 'DORITOS', 'FANDANGOS', 'RUFFLES', 'TORCIDA'];
            const foodsCategories = ['TODDY', 'TODDYNHO', 'QUAKER', 'KEROCOCO'];

            const currentMixPepsico = calculateAverageMixComDevolucao(currentSales, pepsicoCodfors);
            const historyMixPepsico = monthlyKpiAverage(historySales, calculateAverageMixComDevolucao, pepsicoCodfors);

            const currentPositivacaoSalty = calculatePositivacaoPorCestaComDevolucao(currentSales, saltyCategories);
            const historyPositivacaoSalty = monthlyKpiAverage(historySales, calculatePositivacaoPorCestaComDevolucao, saltyCategories);

            const currentPositivacaoFoods = calculatePositivacaoPorCestaComDevolucao(currentSales, foodsCategories);
            const historyPositivacaoFoods = monthlyKpiAverage(historySales, calculatePositivacaoPorCestaComDevolucao, foodsCategories);

            renderKpiCards([ 
                { title: 'Faturamento Total', current: currentTotalFat, history: historyTotalFat / historyMonthsCount, format: 'currency' }, 
                { title: 'Peso Total (Ton)', current: currentTotalPeso / 1000, history: historyTotalPeso / 1000 / historyMonthsCount, format: 'decimal' }, 
                { title: 'Clientes Atendidos', current: currentClients, history: historyClientsAverage, format: 'integer' }, 
                { title: 'Ticket Médio', current: currentTicket, history: historyTicketAverage, format: 'currency' },
                { title: 'Mix por PDV (Pepsico)', current: currentMixPepsico, history: historyMixPepsico, format: 'mix' },
                { title: 'Positivação Salty', current: currentPositivacaoSalty, history: historyPositivacaoSalty, format: 'integer' },
                { title: 'Positivação Foods', current: currentPositivacaoFoods, history: historyPositivacaoFoods, format: 'integer' }
            ]);
            
            const currentYear = lastSaleDate.getFullYear();
            const currentMonth = lastSaleDate.getMonth();
            let currentMonthWeeks = getSundayBasedWeeks(currentYear, currentMonth);

            let excludeLastWeek = false;
            if (currentMonthWeeks.length > 0) {
                const lastWeek = currentMonthWeeks[currentMonthWeeks.length - 1];
                const lastWeekStartDate = lastWeek.start;
                const startDay = lastWeekStartDate.getDay();

                let daysInCurrentMonth = 0;
                let tempDate = new Date(lastWeek.start);
                while (tempDate <= lastWeek.end) {
                    if (tempDate.getMonth() === currentMonth) {
                        daysInCurrentMonth++;
                    }
                    tempDate.setDate(tempDate.getDate() + 1);
                }

                if ((startDay === 0 || startDay === 6) && daysInCurrentMonth <= 2) {
                    excludeLastWeek = true;
                }
            }

            if (excludeLastWeek) {
                currentMonthWeeks.pop();
            }

            let salesForWeeklyCharts = [...currentSales];
            if (currentMonthWeeks.length > 0) {
                const firstWeekStartDate = currentMonthWeeks[0].start;
                if (firstWeekStartDate.getMonth() < currentMonth || firstWeekStartDate.getFullYear() < currentYear) {
                    const endOfPreviousMonth = new Date(currentYear, currentMonth, 0);
                    const relevantHistory = historySales.filter(s => {
                        const d = parseDate(s.DTPED);
                        return d >= firstWeekStartDate && d <= endOfPreviousMonth;
                    });
                    salesForWeeklyCharts.push(...relevantHistory);
                }
            }
            

            let currentSalesByWeek = new Array(currentMonthWeeks.length).fill(0);
            salesForWeeklyCharts.forEach(sale => {
                const saleDate = parseDate(sale.DTPED);
                if (!saleDate) return;
                const weekIndex = currentMonthWeeks.findIndex(week => saleDate >= week.start && saleDate <= week.end);
                if (weekIndex !== -1) {
                     currentSalesByWeek[weekIndex] += sale.VLVENDA;
                }
            });
            
            const historySalesByWeekIndex = {};
            historySales.forEach(sale => {
                const saleDate = parseDate(sale.DTPED);
                if (!saleDate) return;
                const saleYear = saleDate.getFullYear();
                const saleMonth = saleDate.getMonth();
                const monthKey = `${saleYear}-${saleMonth}`;
                const monthWeeks = getSundayBasedWeeks(saleYear, saleMonth);
                const weekIndex = monthWeeks.findIndex(week => saleDate >= week.start && saleDate <= week.end);
                if (weekIndex !== -1) {
                    if (!historySalesByWeekIndex[weekIndex]) historySalesByWeekIndex[weekIndex] = {};
                    if (!historySalesByWeekIndex[weekIndex][monthKey]) historySalesByWeekIndex[weekIndex][monthKey] = 0;
                    historySalesByWeekIndex[weekIndex][monthKey] += sale.VLVENDA;
                }
            });

            const historyAvgSalesByWeek = new Array(currentMonthWeeks.length).fill(0);
            for (let i = 0; i < currentMonthWeeks.length; i++) {
                const weekDataByMonth = historySalesByWeekIndex[i] || {};
                const weeklyTotals = Object.values(weekDataByMonth);
                if (weeklyTotals.length > 0) {
                    const totalSum = weeklyTotals.reduce((a, b) => a + b, 0);
                    const divisor = Math.max(historyMonthsCount, 1);
                    historyAvgSalesByWeek[i] = totalSum / divisor;
                }
            }
            
            if (useTendencyComparison) {
                const today = lastSaleDate;
                const currentWeekIndex = currentMonthWeeks.findIndex(w => today >= w.start && today <= w.end);

                for (let i = 0; i < currentMonthWeeks.length; i++) {
                    if (i < currentWeekIndex) {
                        continue;
                    } else if (i === currentWeekIndex) {
                        const currentWeek = currentMonthWeeks[currentWeekIndex];
                        const salesThisWeekSoFar = salesForWeeklyCharts.filter(s => {
                            const d = parseDate(s.DTPED);
                            return d >= currentWeek.start && d <= today;
                        });
                        const totalSoldThisWeek = salesThisWeekSoFar.reduce((sum, s) => sum + s.VLVENDA, 0);
                        
                        let workingDaysPassed = 0;
                        let totalWorkingDays = 0;
                        for (let d = new Date(currentWeek.start); d <= currentWeek.end; d.setDate(d.getDate() + 1)) {
                            const dayOfWeek = d.getDay();
                            if (dayOfWeek >= 1 && dayOfWeek <= 5 && !isHoliday(d, selectedHolidays)) {
                                totalWorkingDays++;
                                if (d <= today) {
                                    workingDaysPassed++;
                                }
                            }
                        }
                        
                        if (workingDaysPassed > 0 && totalWorkingDays > 0) {
                            const dailyAverage = totalSoldThisWeek / workingDaysPassed;
                            currentSalesByWeek[i] = dailyAverage * totalWorkingDays;
                        } else {
                            currentSalesByWeek[i] = historyAvgSalesByWeek[i] || 0;
                        }
                    } else { 
                        currentSalesByWeek[i] = historyAvgSalesByWeek[i] || 0;
                    }
                }
            }

            if (comparisonChartType === 'weekly') {
                monthlyComparisonChartContainer.classList.add('hidden');
                weeklyComparisonChartContainer.classList.remove('hidden');
                comparisonChartTitle.textContent = 'Comparativo de Faturamento Semanal';
                const weekLabels = currentMonthWeeks.map((w, i) => `Semana ${i + 1}`);
                
                createChart('weeklyComparisonChart', 'line', weekLabels, [
                    { label: useTendencyComparison ? 'Tendência Semanal' : 'Mês Atual', data: currentSalesByWeek, borderColor: '#14b8a6', tension: 0.2, pointRadius: 5, pointBackgroundColor: '#14b8a6', borderWidth: 2.5 }, 
                    { label: 'Média Trimestre', data: historyAvgSalesByWeek, borderColor: '#f97316', tension: 0.2, pointRadius: 5, pointBackgroundColor: '#f97316', borderWidth: 2.5 }
                ], { 
                    plugins: { 
                        legend: { display: true, position: 'top', align: 'end' }
                    },
                    layout: { padding: { bottom: 0 } }
                });

            } else if (comparisonChartType === 'monthly') {
                weeklyComparisonChartContainer.classList.add('hidden');
                monthlyComparisonChartContainer.classList.remove('hidden');
                comparisonChartTitle.textContent = 'Comparativo de Faturamento Mensal';

                let monthlyCurrentSales = currentSales;
                if (useTendencyComparison) {
                    const totalDays = getWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays);
                    const passedDays = getPassedWorkingDaysInMonth(currentYear, currentMonth, selectedHolidays, lastSaleDate);
                    
                    if (totalDays > 0 && passedDays > 0 && passedDays <= totalDays) {
                        const projectionFactor = totalDays / passedDays;
                        const currentTotal = monthlyCurrentSales.reduce((sum, item) => sum + item.VLVENDA, 0);
                        const projectedTotal = currentTotal * projectionFactor;
                        
                        monthlyCurrentSales = [{ VLVENDA: projectedTotal, DTPED: new Date() }];
                    }
                }
                const monthlyCurrentTotalFat = monthlyCurrentSales.reduce((sum, item) => sum + item.VLVENDA, 0);

                const salesByMonth = {};
                historySales.forEach(sale => {
                    const saleDate = parseDate(sale.DTPED);
                    if (!saleDate) return;
                    const monthKey = `${saleDate.getFullYear()}-${String(saleDate.getMonth() + 1).padStart(2, '0')}`;
                    salesByMonth[monthKey] = (salesByMonth[monthKey] || 0) + sale.VLVENDA;
                });

                const sortedMonths = Object.keys(salesByMonth).sort();
                const monthLabels = sortedMonths.map(monthKey => {
                    const [year, month] = monthKey.split('-');
                    return new Date(parseInt(year), parseInt(month) - 1, 1).toLocaleString('pt-BR', { month: 'short', year: '2-digit' });
                });
                const monthValues = sortedMonths.map(monthKey => salesByMonth[monthKey]);

                let currentMonthLabel = 'Mês Atual';
                if (currentSales.length > 0) {
                    const firstSaleDate = parseDate(currentSales[0].DTPED) || new Date();
                    currentMonthLabel = firstSaleDate.toLocaleString('pt-BR', { month: 'short', year: '2-digit' });
                }
                
                const existingIndex = monthLabels.indexOf(currentMonthLabel);
                if (existingIndex !== -1) {
                    monthValues[existingIndex] = monthlyCurrentTotalFat;
                } else {
                    monthLabels.push(currentMonthLabel);
                    monthValues.push(monthlyCurrentTotalFat);
                }

                createChart('monthlyComparisonChart', 'bar', monthLabels, [{
                    label: 'Faturamento Mensal',
                    data: monthValues,
                    backgroundColor: (context) => {
                        const chart = context.chart;
                        const {ctx, chartArea} = chart;
                        if (!chartArea) { return null; }
                        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                        gradient.addColorStop(0, 'rgba(20, 184, 166, 0.7)');
                        gradient.addColorStop(1, 'rgba(139, 92, 246, 0.7)');
                        return gradient;
                    },
                    borderColor: (context) => {
                        const chart = context.chart;
                        const {ctx, chartArea} = chart;
                        if (!chartArea) { return null; }
                        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                        gradient.addColorStop(0, '#14b8a6');
                        gradient.addColorStop(1, '#8b5cf6');
                        return gradient;
                    },
                    borderWidth: 2
                }], {
                    layout: { padding: { top: 20 } },
                    plugins: {
                        legend: { display: false },
                        datalabels: {
                            color: '#ffffff',
                            anchor: 'end',
                            align: 'top',
                            offset: 4,
                            font: { weight: 'bold' },
                            formatter: (value) => {
                                if (value >= 1000000) return 'R$ ' + (value / 1000000).toFixed(2) + ' M';
                                return 'R$ ' + (value / 1000).toFixed(0) + 'k';
                            }
                        }
                    }
                });
            }
            
            const salesByWeekAndDay = {};
            currentMonthWeeks.forEach((w, i) => {
                salesByWeekAndDay[i + 1] = new Array(7).fill(0);
            });

            salesForWeeklyCharts.forEach(sale => {
                const saleDate = parseDate(sale.DTPED);
                if (!saleDate) return;
                const weekIndex = currentMonthWeeks.findIndex(week => saleDate >= week.start && saleDate <= week.end);
                if (weekIndex !== -1) {
                    const dayOfWeek = saleDate.getDay();
                    salesByWeekAndDay[weekIndex + 1][dayOfWeek] += sale.VLVENDA;
                }
            });

            if (useTendencyComparison) {
                const today = lastSaleDate;
                const currentWeekIndex = currentMonthWeeks.findIndex(w => today >= w.start && today <= w.end);

                const historicalDayWeights = {}; 
                const salesByWeekDayMonth = {}; 
                
                historySales.forEach(sale => {
                    const d = parseDate(sale.DTPED);
                    if (!d) return;
                    const monthKey = `${d.getFullYear()}-${d.getMonth()}`;
                    const monthWeeks = getSundayBasedWeeks(d.getFullYear(), d.getMonth());
                    const weekIndex = monthWeeks.findIndex(w => d >= w.start && d <= w.end);
                    if (weekIndex !== -1) {
                        if (!salesByWeekDayMonth[monthKey]) salesByWeekDayMonth[monthKey] = {};
                        if (!salesByWeekDayMonth[monthKey][weekIndex]) salesByWeekDayMonth[monthKey][weekIndex] = new Array(7).fill(0);
                        salesByWeekDayMonth[monthKey][weekIndex][d.getDay()] += sale.VLVENDA;
                    }
                });

                for (let i = 0; i < currentMonthWeeks.length; i++) {
                    const totalsByDay = new Array(7).fill(0);
                    let monthCount = 0;
                    for (const monthKey in salesByWeekDayMonth) {
                        if (salesByWeekDayMonth[monthKey][i]) {
                            monthCount++;
                            for (let day = 0; day < 7; day++) {
                                totalsByDay[day] += salesByWeekDayMonth[monthKey][i][day] || 0;
                            }
                        }
                    }
                    
                    const weeklyTotal = totalsByDay.reduce((a, b) => a + b, 0);
                    if (weeklyTotal > 0) {
                        historicalDayWeights[i] = totalsByDay.map(dayTotal => dayTotal / weeklyTotal);
                    } else {
                        historicalDayWeights[i] = [0, 0.2, 0.2, 0.2, 0.2, 0.2, 0]; 
                    }
                }

                for (let i = currentWeekIndex + 1; i < currentMonthWeeks.length; i++) {
                    const projectedTotalForWeek = currentSalesByWeek[i];
                    const weights = historicalDayWeights[i];
                    for (let day = 0; day < 7; day++) {
                        salesByWeekAndDay[i + 1][day] = projectedTotalForWeek * weights[day];
                    }
                }

                if (currentWeekIndex !== -1) {
                    const week = currentMonthWeeks[currentWeekIndex];
                    const soldInCurrentWeek = Object.values(salesByWeekAndDay[currentWeekIndex + 1]).reduce((a, b) => a + b, 0);
                    const projectedTotalForCurrentWeek = currentSalesByWeek[currentWeekIndex];
                    const remainingToSell = projectedTotalForCurrentWeek - soldInCurrentWeek;
                    
                    let futureDayWeights = [];
                    let totalFutureWeight = 0;
                    for (let d = new Date(week.start); d <= week.end; d.setDate(d.getDate() + 1)) {
                        if (d > today) {
                            const dayIndex = d.getDay();
                            const weight = historicalDayWeights[currentWeekIndex][dayIndex];
                            futureDayWeights.push({ day: dayIndex, weight: weight });
                            totalFutureWeight += weight;
                        }
                    }

                    if (totalFutureWeight > 0 && remainingToSell > 0) {
                        futureDayWeights.forEach(item => {
                            const distributedAmount = (item.weight / totalFutureWeight) * remainingToSell;
                            salesByWeekAndDay[currentWeekIndex + 1][item.day] = distributedAmount;
                        });
                    }
                }
            }
            
            const dayNames = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
            const professionalPalette = ['#a855f7', '#6366f1', '#ec4899', '#f97316', '#8b5cf6', '#06b6d4', '#f59e0b'];
            const dailyBreakdownDatasets = dayNames.map((dayName, dayIndex) => {
                return {
                    label: dayName,
                    data: currentMonthWeeks.map((week, weekIndex) => salesByWeekAndDay[weekIndex + 1][dayIndex]),
                    backgroundColor: professionalPalette[dayIndex % professionalPalette.length],
                };
            });

            const weekLabelsForDailyChart = currentMonthWeeks.map((week, index) => {
                const startDateStr = week.start.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
                const endDateStr = week.end.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
                return `S${index + 1} (${startDateStr} à ${endDateStr})`;
            });

            if (dailyBreakdownDatasets.some(ds => ds.data.some(d => d > 0))) {
                createChart('dailyWeeklyComparisonChart', 'bar', weekLabelsForDailyChart, dailyBreakdownDatasets, {
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: { 
                            mode: 'point', 
                            intersect: true 
                        },
                        datalabels: { display: false }
                    },
                    scales: {
                        x: { stacked: false },
                        y: { stacked: false, ticks: { callback: (v) => (v / 1000).toFixed(0) + 'k' } }
                    }
                });
            } else {
                showNoDataMessage('dailyWeeklyComparisonChart', 'Sem dados para exibir.');
            }

            const supervisorComparison = {};
            const activeSupervisors = [...new Set(allSalesData.map(s => s.SUPERV))].filter(Boolean);
            activeSupervisors.forEach(sup => supervisorComparison[sup] = { current: 0, history: 0 });
            currentSales.forEach(s => { if(s.SUPERV && supervisorComparison[s.SUPERV]) supervisorComparison[s.SUPERV].current += s.VLVENDA; });
            historySales.forEach(s => { if(s.SUPERV && supervisorComparison[s.SUPERV]) supervisorComparison[s.SUPERV].history += s.VLVENDA; });
            Object.keys(supervisorComparison).forEach(sup => supervisorComparison[sup].history /= historyMonthsCount);
            const supervisorTableBody = document.getElementById('supervisorComparisonTableBody');
            supervisorTableBody.innerHTML = Object.entries(supervisorComparison).map(([sup, data]) => { const variation = data.history > 0 ? ((data.current - data.history) / data.history) * 100 : (data.current > 0 ? 100 : 0); const colorClass = variation > 0 ? 'text-green-400' : variation < 0 ? 'text-red-400' : 'text-slate-400'; return `<tr class="hover:bg-slate-700"><td class="px-4 py-2">${sup}</td><td class="px-4 py-2 text-right">${data.history.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td><td class="px-4 py-2 text-right">${data.current.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</td><td class="px-4 py-2 text-right ${colorClass}">${variation.toFixed(2)}%</td></tr>`; }).join('');
        }

        // NOVA FUNÇÃO PARA ATUALIZAR A VIEW DE ESTOQUE
        function updateStockView() {
            const filial = stockFilialFilter.value;
            const activeStockMap = getActiveStockMap(filial);

            let productsToDisplay = [...new Set(allSalesData.map(p => p.PRODUTO))];

            if (selectedStockSuppliers.length > 0) {
                const productsFromSuppliers = new Set(allSalesData.filter(s => selectedStockSuppliers.includes(s.CODFOR)).map(s => s.PRODUTO));
                productsToDisplay = productsToDisplay.filter(p => productsFromSuppliers.has(p));
            }

            if (selectedStockProducts.length > 0) {
                productsToDisplay = productsToDisplay.filter(p => selectedStockProducts.includes(p));
            }

            const productDetails = new Map();
            allSalesData.forEach(s => {
                if (!productDetails.has(s.PRODUTO)) {
                    productDetails.set(s.PRODUTO, {
                        descricao: s.DESCRICAO,
                        fornecedor: s.FORNECEDOR,
                        codfor: s.CODFOR
                    });
                }
            });

            const historyMonthsCount = getUniqueMonthCount(allHistoryData);
            const salesByProductHistory = {};
            allHistoryData.forEach(s => {
                if (!s.PRODUTO) return;
                salesByProductHistory[s.PRODUTO] = (salesByProductHistory[s.PRODUTO] || 0) + s.QTVENDA_EMBALAGEM_MASTER;
            });

            const tableData = productsToDisplay.map(code => {
                const details = productDetails.get(code) || {};
                const stock = activeStockMap.get(code) || 0;
                const avgSale = (salesByProductHistory[code] || 0) / historyMonthsCount;
                const trendDays = avgSale > 0 ? (stock / (avgSale / 22)) : Infinity; // 22 dias úteis no mês

                return {
                    code,
                    descricao: details.descricao || 'N/A',
                    fornecedor: details.fornecedor || 'N/A',
                    stock,
                    avgSale,
                    trendDays
                };
            }).sort((a, b) => a.descricao.localeCompare(b.descricao));

            stockAnalysisTableBody.innerHTML = tableData.map(item => {
                const trendText = isFinite(item.trendDays) ? `${Math.floor(item.trendDays)} dias` : 'N/A';
                let trendColor = 'text-slate-400';
                if (isFinite(item.trendDays)) {
                    if (item.trendDays < 15) trendColor = 'text-red-400';
                    else if (item.trendDays < 30) trendColor = 'text-yellow-400';
                    else trendColor = 'text-green-400';
                }

                return `
                    <tr class="hover:bg-slate-700/50">
                        <td class="px-4 py-2 text-xs">(${item.code}) ${item.descricao}</td>
                        <td class="px-4 py-2 text-xs">${item.fornecedor}</td>
                        <td class="px-4 py-2 text-right text-xs">${item.stock.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                        <td class="px-4 py-2 text-right text-xs">${item.avgSale.toLocaleString('pt-BR', {maximumFractionDigits: 2})}</td>
                        <td class="px-4 py-2 text-right text-xs font-bold ${trendColor}">${trendText}</td>
                    </tr>
                `;
            }).join('');
            
            // Lógica para os gráficos da tela de estoque (a ser implementada)
            const stockBySupplier = {};
            tableData.forEach(item => {
                 stockBySupplier[item.fornecedor] = (stockBySupplier[item.fornecedor] || 0) + item.stock;
            });
            const sortedStockBySupplier = Object.entries(stockBySupplier).sort((a, b) => b[1] - a[1]).slice(0, 10);
            if (sortedStockBySupplier.length > 0) {
                 createChart('stockBySupplierChart', 'bar', sortedStockBySupplier.map(s => s[0]), sortedStockBySupplier.map(s => s[1]), { indexAxis: 'y' });
            } else {
                showNoDataMessage('stockBySupplierChart', 'Sem dados de estoque para exibir.');
            }

            const criticalStock = tableData.filter(p => isFinite(p.trendDays) && p.trendDays < 15).sort((a,b) => a.trendDays - b.trendDays).slice(0, 10);
             if (criticalStock.length > 0) {
                 createChart('criticalStockChart', 'bar', criticalStock.map(p => `(${p.code}) ${p.descricao}`), criticalStock.map(p => p.trendDays), { indexAxis: 'y', plugins: { datalabels: { formatter: (v) => `${v.toFixed(0)}d` } } });
            } else {
                showNoDataMessage('criticalStockChart', 'Nenhum produto em estado crítico.');
            }

        }


        function renderKpiCards(kpis) {
            const container = document.getElementById('comparison-kpi-container');
            
            const formatValue = (val, format) => {
                if (format === 'currency') return val.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
                if (format === 'decimal') return val.toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
                if (format === 'mix') return val.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                return val.toLocaleString('pt-BR', { maximumFractionDigits: 0 });
            };

            container.innerHTML = kpis.map(kpi => {
                const variation = kpi.history > 0 ? ((kpi.current - kpi.history) / kpi.history) * 100 : (kpi.current > 0 ? 100 : 0);
                const colorClass = variation > 0 ? 'text-green-400' : variation < 0 ? 'text-red-400' : 'text-slate-400';
                
                return `<div class="bg-slate-800 p-4 rounded-lg text-center">
                            <p class="text-slate-400 text-sm">${kpi.title}</p>
                            <p class="text-2xl font-bold text-white my-2">${formatValue(kpi.current, kpi.format)}</p>
                            <p class="text-sm ${colorClass}">${variation.toFixed(2)}% vs Média do Trimestre</p>
                            <p class="text-xs text-slate-500">Média Trim.: ${formatValue(kpi.history, kpi.format)}</p>
                        </div>`;
            }).join('');
        }
        
        function openModal(pedidoId) {
            const orderInfo = aggregatedOrders.find(order => order.PEDIDO == pedidoId);
            const itemsDoPedido = allSalesData.filter(item => item.PEDIDO == pedidoId);
            if (!orderInfo) return;
            modalPedidoId.textContent = pedidoId;
            modalHeaderInfo.innerHTML = `<div><p class="font-bold">Cód. Cliente:</p><p>${orderInfo.CODCLI || 'N/A'}</p></div><div><p class="font-bold">Cliente:</p><p>${orderInfo.CLIENTE_NOME || 'N/A'}</p></div><div><p class="font-bold">Vendedor:</p><p>${orderInfo.NOME || 'N/A'}</p></div><div><p class="font-bold">Data Pedido:</p><p>${formatDate(orderInfo.DTPED)}</p></div><div><p class="font-bold">Data Faturamento:</p><p>${formatDate(orderInfo.DTSAIDA)}</p></div><div><p class="font-bold">Cidade:</p><p>${orderInfo.CIDADE || 'N/A'}</p></div>`;
            modalTableBody.innerHTML = itemsDoPedido.map(item => { const unitPrice = (item.QTVENDA > 0) ? (item.VLVENDA / item.QTVENDA) : 0; return `<tr class="hover:bg-slate-700"><td class="px-4 py-2">(${item.PRODUTO}) ${item.DESCRICAO}</td><td class="px-4 py-2 text-right">${item.QTVENDA}</td><td class="px-4 py-2 text-right">${item.TOTPESOLIQ.toLocaleString('pt-BR', { minimumFractionDigits: 2 })} Kg</td><td class="px-4 py-2 text-right"><div class="tooltip">${unitPrice.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}<span class="tooltip-text" style="width: max-content; transform: translateX(-50%); margin-left: 0;">Subtotal: ${item.VLVENDA.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</span></div></td></tr>`; }).join('');
            modalFooterTotal.innerHTML = `<p class="text-lg font-bold text-teal-400">Mix de Produtos: ${itemsDoPedido.length}</p><p class="text-lg font-bold text-emerald-400">Total do Pedido: ${orderInfo.VLVENDA.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' })}</p>`;
            modal.classList.remove('hidden');
        }

        function openClientModal(codcli) {
            const clientData = allClientsData.find(c => String(c['Código']) === String(codcli));
            if (!clientData) return;
            let finalAddress = clientData.endereco || 'N/A';
            const number = clientData.numero || 'SN';
            if (number !== 'SN' && finalAddress !== 'N/A' && !finalAddress.includes(number)) finalAddress += `, ${number}`;
            clientModalContent.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4 text-sm"><div><p class="font-bold text-slate-400">Código:</p><p>${clientData['Código'] || 'N/A'}</p></div><div><p class="font-bold text-slate-400">CNPJ/CPF:</p><p>${clientData.cnpj_cpf || 'N/A'}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Insc. Est. / Produtor:</p><p>${clientData.inscricaoEstadual || 'N/A'}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Razão Social:</p><p>${clientData.razaoSocial || 'N/A'}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Nome Fantasia:</p><p>${clientData.fantasia || 'N/A'}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">Endereço:</p><p>${finalAddress}</p></div><div><p class="font-bold text-slate-400">Bairro:</p><p>${clientData.bairro || 'N/A'}</p></div><div><p class="font-bold text-slate-400">Cidade:</p><p>${clientData.cidade || 'N/A'}</p></div><div><p class="font-bold text-slate-400">CEP:</p><p>${clientData.cep || 'N/A'}</p></div><div><p class="font-bold text-slate-400">Telefone:</p><p>${clientData.telefone || 'N/A'}</p></div><div class="md:col-span-2"><p class="font-bold text-slate-400">E-mail:</p><p>${clientData.email || 'N/A'}</p></div><div><p class="font-bold text-slate-400">Ramo de Atividade:</p><p>${clientData.ramo || 'N/A'}</p></div><div><p class="font-bold text-slate-400">Última Compra:</p><p>${formatDate(clientData.ultimaCompra)}</p></div></div>`;
            clientModal.classList.remove('hidden');
        }
        
        function exportClientsPDF(clientList, title, filename, includeFaturamento) {
             if (clientList.length === 0) return;
            const { jsPDF } = window.jspdf; const doc = new jsPDF();
            const supervisor = citySupervisorFilter.value || 'Todos'; const vendedor = selectedCitySellers.length > 0 ? selectedCitySellers.join(', ') : 'Todos';
            const generationDate = new Date().toLocaleString('pt-BR'); const today = new Date();
            const firstDay = new Date(today.getFullYear(), today.getMonth(), 1).toLocaleDateString('pt-BR');
            const lastDay = new Date(today.getFullYear(), today.getMonth() + 1, 0).toLocaleDateString('pt-BR');
            doc.setFontSize(18); doc.text(title, 14, 22); doc.setFontSize(11); doc.setTextColor(100);
            doc.text(`Período de Análise: ${firstDay} a ${lastDay}`, 14, 32);
            doc.text(`Supervisor: ${supervisor}`, 14, 38); doc.text(`Vendedor: ${vendedor}`, 14, 44);
            doc.text(`Data de Emissão: ${generationDate}`, 14, 50);
            const tableColumn = ["Código", "Cliente", "Bairro", "Cidade", "Últ. Compra"];
            if (includeFaturamento) tableColumn.splice(2, 0, "Faturamento");
            const tableRows = [];
            clientList.forEach(client => {
                const clientData = [ client['Código'] || '', client.fantasia || client.razaoSocial || '', client.bairro || '', client.cidade || '', formatDate(client.ultimaCompra) || 'N/A' ];
                if (includeFaturamento) clientData.splice(2, 0, (client.total || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' }));
                tableRows.push(clientData);
            });
            doc.autoTable({ head: [tableColumn], body: tableRows, startY: 60, theme: 'grid', styles: { fontSize: 8, cellPadding: 1.5 }, headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8, fontStyle: 'bold' }, alternateRowStyles: { fillColor: [240, 248, 255] }, margin: { top: 10 } });
            const pageCount = doc.internal.getNumberOfPages();
            for(let i = 1; i <= pageCount; i++) { doc.setPage(i); doc.setFontSize(9); doc.setTextColor(150); doc.text(`Página ${i} de ${pageCount}`, doc.internal.pageSize.width / 2, doc.internal.pageSize.height - 10, { align: 'center' }); }
            const fileNameVendedor = vendedor.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'geral';
            doc.save(`${filename}_${fileNameVendedor}_${new Date().toISOString().slice(0,10)}.pdf`);
        }

        function renderCalendar(year, month) {
            const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
            
            let calendarHTML = `
                <div class="flex justify-between items-center mb-4">
                    <button id="prev-month-btn" class="p-2 rounded-full hover:bg-slate-600">&lt;</button>
                    <h3 class="font-bold text-lg">${monthNames[month]} ${year}</h3>
                    <button id="next-month-btn" class="p-2 rounded-full hover:bg-slate-600">&gt;</button>
                </div>
                <div class="grid grid-cols-7 gap-1 text-center text-xs text-slate-400 mb-2">
                    <div>Dom</div><div>Seg</div><div>Ter</div><div>Qua</div><div>Qui</div><div>Sex</div><div>Sáb</div>
                </div>
                <div id="calendar-grid" class="grid grid-cols-7 gap-1">
            `;
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            for (let i = 0; i < firstDay; i++) {
                calendarHTML += `<div></div>`;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dateString = date.toISOString().split('T')[0];
                const isSelected = selectedHolidays.includes(dateString);
                const isToday = date.getTime() === lastSaleDate.getTime();
                let dayClasses = 'p-2 rounded-full cursor-pointer hover:bg-slate-600 flex items-center justify-center';
                if (isSelected) dayClasses += ' bg-red-500 text-white font-bold';
                if (isToday) dayClasses += ' border-2 border-teal-400';

                calendarHTML += `<div class="${dayClasses}" data-date="${dateString}">${day}</div>`;
            }

            calendarHTML += `</div>`;
            calendarContainer.innerHTML = calendarHTML;
        }
        
        function initializeRedeFilters() {
            const hasRedeData = allClientsData.some(client => client.ramo && client.ramo !== 'N/A');

            const mainRedeFilterWrapper = document.getElementById('main-rede-filter-wrapper');
            const cityRedeFilterWrapper = document.getElementById('city-rede-filter-wrapper');
            const comparisonRedeFilterWrapper = document.getElementById('comparison-rede-filter-wrapper');

            if (mainRedeFilterWrapper) mainRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
            if (cityRedeFilterWrapper) cityRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
            if (comparisonRedeFilterWrapper) comparisonRedeFilterWrapper.style.display = hasRedeData ? '' : 'none';
        }

        function debounce(func, delay = 250) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        function setupEventListeners() {
            viewTableBtn.addEventListener('click', () => { chartView.classList.add('hidden'); tableView.classList.remove('hidden'); viewTableBtn.classList.add('hidden'); viewChartBtn.classList.remove('hidden'); updateAllVisuals(); });
            viewChartBtn.addEventListener('click', () => { tableView.classList.add('hidden'); chartView.classList.remove('hidden'); viewChartBtn.classList.add('hidden'); viewTableBtn.classList.remove('hidden'); updateAllVisuals(); });
            viewComparisonBtn.addEventListener('click', () => { mainDashboard.classList.add('hidden'); comparisonView.classList.remove('hidden'); updateAllComparisonFilters(); updateComparisonView(); });
            viewStockBtn.addEventListener('click', () => { mainDashboard.classList.add('hidden'); stockView.classList.remove('hidden'); updateStockView(); }); // NOVO
            showCityBtn.addEventListener('click', () => { resetMainFilters(); mainDashboard.classList.add('hidden'); cityView.classList.remove('hidden'); document.getElementById('city-view-content').classList.add('hidden'); document.getElementById('city-view-loader').classList.remove('hidden'); setTimeout(() => { populateSupervisors('city-supervisor-filter', allSalesData); selectedCitySellers = updateSellerFilter('', cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData); updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData); updateCityView(); document.getElementById('city-view-loader').classList.add('hidden'); document.getElementById('city-view-content').classList.remove('hidden'); }, 10); });
            backToMainFromCityBtn.addEventListener('click', () => { resetCityFilters(); cityView.classList.add('hidden'); mainDashboard.classList.remove('hidden'); updateAllVisuals(); });
            showWeeklyBtn.addEventListener('click', () => { resetMainFilters(); mainDashboard.classList.add('hidden'); weeklyView.classList.remove('hidden'); populateWeeklyFilters(); updateWeeklyView(); });
            backToMainFromWeeklyBtn.addEventListener('click', () => { weeklyView.classList.add('hidden'); mainDashboard.classList.remove('hidden'); currentWeeklyFornecedor = ''; updateAllVisuals(); });
            backToMainFromComparisonBtn.addEventListener('click', () => { comparisonView.classList.add('hidden'); mainDashboard.classList.remove('hidden'); updateAllVisuals(); });
            backToMainFromStockBtn.addEventListener('click', () => { stockView.classList.add('hidden'); mainDashboard.classList.remove('hidden'); updateAllVisuals(); }); // NOVO
            
            supervisorFilter.addEventListener('change', () => { selectedSellers = []; updateSellerFilter(supervisorFilter.value, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData); updateAllVisuals(); });
            vendedorFilterBtn.addEventListener('click', () => vendedorFilterDropdown.classList.toggle('hidden'));
            vendedorFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedSellers.push(value); else selectedSellers = selectedSellers.filter(s => s !== value); selectedSellers = updateSellerFilter(supervisorFilter.value, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData); updateAllVisuals(); } });
            posicaoFilter.addEventListener('change', updateAllVisuals);
            codcliFilter.addEventListener('input', (e) => e.target.value = e.target.value.replace(/[^0-9]/g, ''));
            codcliFilter.addEventListener('change', updateAllVisuals);
            clearFiltersBtn.addEventListener('click', resetMainFilters);
            
            mainComRedeBtn.addEventListener('click', () => mainRedeFilterDropdown.classList.toggle('hidden'));
            mainRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    mainRedeGroupFilter = button.dataset.group;
                    mainRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    if (mainRedeGroupFilter !== 'com_rede') {
                        mainRedeFilterDropdown.classList.add('hidden');
                        selectedMainRedes = [];
                    }
                    updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
                    updateAllVisuals();
                }
            });
            mainRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedMainRedes.push(value);
                    else selectedMainRedes = selectedMainRedes.filter(r => r !== value);
                    selectedMainRedes = updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
                    updateAllVisuals();
                }
            });

            citySupervisorFilter.addEventListener('change', () => { selectedCitySellers = []; selectedCitySellers = updateSellerFilter(citySupervisorFilter.value, cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData); validateCityFilter(); updateCityView(); });
            cityVendedorFilterBtn.addEventListener('click', () => cityVendedorFilterDropdown.classList.toggle('hidden'));
            cityVendedorFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedCitySellers.push(value); else selectedCitySellers = selectedCitySellers.filter(s => s !== value); selectedCitySellers = updateSellerFilter(citySupervisorFilter.value, cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData); validateCityFilter(); updateCityView(); } });
            
            cityComRedeBtn.addEventListener('click', () => cityRedeFilterDropdown.classList.toggle('hidden'));
            cityRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    cityRedeGroupFilter = button.dataset.group;
                    cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');

                    if (cityRedeGroupFilter !== 'com_rede') {
                        cityRedeFilterDropdown.classList.add('hidden');
                        selectedCityRedes = [];
                    }
                    updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData);
                    updateCityView();
                }
            });
            cityRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedCityRedes.push(value);
                    else selectedCityRedes = selectedCityRedes.filter(r => r !== value);
                    
                    cityRedeGroupFilter = 'com_rede';
                    cityRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    cityComRedeBtn.classList.add('active');

                    selectedCityRedes = updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData);
                    updateCityView();
                }
            });


            clearCityFiltersBtn.addEventListener('click', resetCityFilters);
            cityCodCliFilter.addEventListener('input', (e) => e.target.value = e.target.value.replace(/[^0-9]/g, ''));
            cityCodCliFilter.addEventListener('change', updateCityView);
            cityNameFilter.addEventListener('input', (e) => { e.target.value = e.target.value.replace(/[0-9]/g, ''); const relevantClients = getRelevantClientsForCityFilter(); updateCitySuggestions(cityNameFilter, citySuggestions, relevantClients); });
            cityNameFilter.addEventListener('focus', () => { const relevantClients = getRelevantClientsForCityFilter(); citySuggestions.classList.remove('manual-hide'); updateCitySuggestions(cityNameFilter, citySuggestions, relevantClients); });
            cityNameFilter.addEventListener('blur', () => setTimeout(() => citySuggestions.classList.add('hidden'), 150));
            cityNameFilter.addEventListener('keydown', (e) => { if (e.key === 'Enter') { citySuggestions.classList.add('hidden', 'manual-hide'); updateCityView(); e.target.blur(); } });
            
            document.addEventListener('click', (e) => { 
                if (!vendedorFilterBtn.contains(e.target) && !vendedorFilterDropdown.contains(e.target)) vendedorFilterDropdown.classList.add('hidden'); 
                if (!cityVendedorFilterBtn.contains(e.target) && !cityVendedorFilterDropdown.contains(e.target)) cityVendedorFilterDropdown.classList.add('hidden'); 
                if (!cityComRedeBtn.contains(e.target) && !cityRedeFilterDropdown.contains(e.target)) cityRedeFilterDropdown.classList.add('hidden');
                if (!mainComRedeBtn.contains(e.target) && !mainRedeFilterDropdown.contains(e.target)) mainRedeFilterDropdown.classList.add('hidden');
                if (!comparisonComRedeBtn.contains(e.target) && !comparisonRedeFilterDropdown.contains(e.target)) comparisonRedeFilterDropdown.classList.add('hidden');
                if (!comparisonVendedorFilterBtn.contains(e.target) && !comparisonVendedorFilterDropdown.contains(e.target)) comparisonVendedorFilterDropdown.classList.add('hidden'); 
                if (!comparisonSupplierFilterBtn.contains(e.target) && !comparisonSupplierFilterDropdown.contains(e.target)) comparisonSupplierFilterDropdown.classList.add('hidden'); 
                if (!comparisonProductFilterBtn.contains(e.target) && !comparisonProductFilterDropdown.contains(e.target)) comparisonProductFilterDropdown.classList.add('hidden');
                if (!stockSupplierFilterBtn.contains(e.target) && !stockSupplierFilterDropdown.contains(e.target)) stockSupplierFilterDropdown.classList.add('hidden'); // NOVO
                if (!stockProductFilterBtn.contains(e.target) && !stockProductFilterDropdown.contains(e.target)) stockProductFilterDropdown.classList.add('hidden'); // NOVO
                if (e.target.closest('[data-pedido-id]')) { e.preventDefault(); openModal(e.target.closest('[data-pedido-id]').dataset.pedidoId); } 
                if (e.target.closest('[data-codcli]')) { e.preventDefault(); openClientModal(e.target.closest('[data-codcli]').dataset.codcli); } 
                if (e.target.closest('#city-suggestions > div')) { cityNameFilter.value = e.target.textContent; citySuggestions.classList.add('hidden'); updateCityView(); } 
                if (e.target.closest('#comparison-city-suggestions > div')) { comparisonCityFilter.value = e.target.textContent; comparisonCitySuggestions.classList.add('hidden'); updateAllComparisonFilters(); updateComparisonView(); } 
                else if (!comparisonCityFilter.contains(e.target)) comparisonCitySuggestions.classList.add('hidden'); 
            });

            fornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(btn => { btn.addEventListener('click', () => { const fornecedor = btn.dataset.fornecedor; if (currentFornecedor === fornecedor) { currentFornecedor = ''; btn.classList.remove('active'); } else { currentFornecedor = fornecedor; fornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); } populateSupervisors('supervisor-filter', allSalesData); selectedSellers = []; updateSellerFilter(supervisorFilter.value, vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData); updateAllVisuals(); }); });
            weeklyFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(btn => { btn.addEventListener('click', () => { const fornecedor = btn.dataset.fornecedor; if (currentWeeklyFornecedor === fornecedor) { currentWeeklyFornecedor = ''; btn.classList.remove('active'); } else { currentWeeklyFornecedor = fornecedor; weeklyFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); btn.classList.add('active'); } updateWeeklyView(); }); });
            weeklySupervisorFilter.addEventListener('change', updateWeeklyView);
            clearWeeklyFiltersBtn.addEventListener('click', resetWeeklyFilters);
            
            const handleComparisonFilterChange = () => {
                updateAllComparisonFilters();
                updateComparisonView();
            };

            comparisonSupervisorFilter.addEventListener('change', handleComparisonFilterChange);
            filialFilter.addEventListener('change', handleComparisonFilterChange);
            comparisonVendedorFilterBtn.addEventListener('click', () => comparisonVendedorFilterDropdown.classList.toggle('hidden'));
            comparisonVendedorFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedComparisonSellers.push(value); else selectedComparisonSellers = selectedComparisonSellers.filter(s => s !== value); handleComparisonFilterChange(); } });
            comparisonFornecedorToggleContainer.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { const fornecedor = e.target.dataset.fornecedor; if (currentComparisonFornecedor === fornecedor) { currentComparisonFornecedor = ''; e.target.classList.remove('active'); } else { currentComparisonFornecedor = fornecedor; comparisonFornecedorToggleContainer.querySelectorAll('.fornecedor-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); } handleComparisonFilterChange(); } });
            comparisonSupplierFilterBtn.addEventListener('click', () => comparisonSupplierFilterDropdown.classList.toggle('hidden'));
            comparisonSupplierFilterDropdown.addEventListener('change', (e) => { if (e.target.type === 'checkbox') { const { value, checked } = e.target; if (checked) selectedComparisonSuppliers.push(value); else selectedComparisonSuppliers = selectedComparisonSuppliers.filter(s => s !== value); handleComparisonFilterChange(); } });
            
            comparisonComRedeBtn.addEventListener('click', () => comparisonRedeFilterDropdown.classList.toggle('hidden'));
            comparisonRedeGroupContainer.addEventListener('click', (e) => {
                if(e.target.closest('button')) {
                    const button = e.target.closest('button');
                    comparisonRedeGroupFilter = button.dataset.group;
                    comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    if (comparisonRedeGroupFilter !== 'com_rede') {
                        comparisonRedeFilterDropdown.classList.add('hidden');
                        selectedComparisonRedes = [];
                    }
                    updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);
                    handleComparisonFilterChange();
                }
            });
            comparisonRedeFilterDropdown.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) selectedComparisonRedes.push(value);
                    else selectedComparisonRedes = selectedComparisonRedes.filter(r => r !== value);
                    
                    comparisonRedeGroupFilter = 'com_rede';
                    comparisonRedeGroupContainer.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    comparisonComRedeBtn.classList.add('active');

                    selectedComparisonRedes = updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);
                    handleComparisonFilterChange();
                }
            });

            comparisonCityFilter.addEventListener('input', () => {
                const cityOptionsData = getComparisonFilteredData({ excludeFilter: 'city' }).historySales;
                updateComparisonCitySuggestions(cityOptionsData);
            });
            comparisonCityFilter.addEventListener('focus', () => {
                const cityOptionsData = getComparisonFilteredData({ excludeFilter: 'city' }).historySales;
                updateComparisonCitySuggestions(cityOptionsData);
            });
            comparisonCityFilter.addEventListener('change', handleComparisonFilterChange); 

            clearComparisonFiltersBtn.addEventListener('click', resetComparisonFilters);
            
            const handleProductFilterChange = (e, selectedArray) => {
                 if (e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if (!selectedArray.includes(value)) selectedArray.push(value);
                    } else {
                        const index = selectedArray.indexOf(value);
                        if (index > -1) selectedArray.splice(index, 1);
                    }
                    return true;
                }
                return false;
            }

            comparisonProductFilterBtn.addEventListener('click', () => {
                updateComparisonProductFilter();
                comparisonProductFilterDropdown.classList.toggle('hidden');
            });
            const debouncedComparisonProductSearch = debounce(updateComparisonProductFilter, 250);
            comparisonProductFilterDropdown.addEventListener('input', (e) => {
                if (e.target.id === 'comparison-product-search-input') {
                    debouncedComparisonProductSearch();
                }
            });
            comparisonProductFilterDropdown.addEventListener('change', (e) => {
                if(handleProductFilterChange(e, selectedComparisonProducts)) {
                    handleComparisonFilterChange();
                    updateComparisonProductFilter();
                }
            });

            // NOVOS EVENT LISTENERS PARA A TELA DE ESTOQUE
            stockFilialFilter.addEventListener('change', updateStockView);
            clearStockFiltersBtn.addEventListener('click', resetStockFilters);
            stockSupplierFilterBtn.addEventListener('click', () => stockSupplierFilterDropdown.classList.toggle('hidden'));
            stockSupplierFilterDropdown.addEventListener('change', (e) => {
                if (e.target.dataset.filterType === 'stock' && e.target.type === 'checkbox') {
                    const { value, checked } = e.target;
                    if (checked) {
                        if(!selectedStockSuppliers.includes(value)) selectedStockSuppliers.push(value);
                    } else {
                        selectedStockSuppliers = selectedStockSuppliers.filter(s => s !== value);
                    }
                    updateStockSupplierFilter();
                    updateStockView();
                }
            });
            stockProductFilterBtn.addEventListener('click', () => {
                updateStockProductFilter();
                stockProductFilterDropdown.classList.toggle('hidden');
            });
            const debouncedStockProductSearch = debounce(updateStockProductFilter, 250);
            stockProductFilterDropdown.addEventListener('input', (e) => {
                if (e.target.id === 'stock-product-search-input') {
                    debouncedStockProductSearch();
                }
            });
            stockProductFilterDropdown.addEventListener('change', (e) => {
                 if(e.target.dataset.filterType === 'stock' && handleProductFilterChange(e, selectedStockProducts)) {
                    updateStockView();
                    updateStockProductFilter();
                }
            });


            comparisonTendencyToggle.addEventListener('click', () => { 
                useTendencyComparison = !useTendencyComparison; 
                comparisonTendencyToggle.textContent = useTendencyComparison ? 'Ver Dados Reais' : 'Calcular Tendência'; 
                comparisonTendencyToggle.classList.toggle('bg-orange-600'); 
                comparisonTendencyToggle.classList.toggle('hover:bg-orange-500'); 
                comparisonTendencyToggle.classList.toggle('bg-purple-600'); 
                comparisonTendencyToggle.classList.toggle('hover:bg-purple-500'); 
                updateComparisonView(); 
            });
            
            toggleWeeklyBtn.addEventListener('click', () => {
                comparisonChartType = 'weekly';
                toggleWeeklyBtn.classList.add('active');
                toggleMonthlyBtn.classList.remove('active');
                updateComparisonView();
            });

            toggleMonthlyBtn.addEventListener('click', () => {
                comparisonChartType = 'monthly';
                toggleMonthlyBtn.classList.add('active');
                toggleWeeklyBtn.classList.remove('active');
                updateComparisonView();
            });

            mainHolidayPickerBtn.addEventListener('click', () => {
                renderCalendar(calendarState.year, calendarState.month);
                holidayModal.classList.remove('hidden');
            });
            comparisonHolidayPickerBtn.addEventListener('click', () => {
                renderCalendar(calendarState.year, calendarState.month);
                holidayModal.classList.remove('hidden');
            });
            holidayModalCloseBtn.addEventListener('click', () => holidayModal.classList.add('hidden'));
            holidayModalDoneBtn.addEventListener('click', () => {
                holidayModal.classList.add('hidden');
                const holidayBtnText = selectedHolidays.length > 0 ? `${selectedHolidays.length} feriado(s)` : 'Selecionar Feriados';
                comparisonHolidayPickerBtn.textContent = holidayBtnText;
                mainHolidayPickerBtn.textContent = holidayBtnText;
                updateComparisonView();
                updateAllVisuals();
            });
            calendarContainer.addEventListener('click', (e) => {
                if (e.target.id === 'prev-month-btn') {
                    calendarState.month--;
                    if (calendarState.month < 0) {
                        calendarState.month = 11;
                        calendarState.year--;
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                } else if (e.target.id === 'next-month-btn') {
                    calendarState.month++;
                    if (calendarState.month > 11) {
                        calendarState.month = 0;
                        calendarState.year++;
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                } else if (e.target.dataset.date) {
                    const dateString = e.target.dataset.date;
                    const index = selectedHolidays.indexOf(dateString);
                    if (index > -1) {
                        selectedHolidays.splice(index, 1);
                    } else {
                        selectedHolidays.push(dateString);
                    }
                    renderCalendar(calendarState.year, calendarState.month);
                }
            });


            document.getElementById('export-active-pdf-btn').addEventListener('click', () => exportClientsPDF(activeClientsForExport, 'Relatório de Clientes Ativos no Mês', 'clientes_ativos', true));
            document.getElementById('export-inactive-pdf-btn').addEventListener('click', () => exportClientsPDF(inactiveClientsForExport, 'Relatório de Clientes Sem Vendas no Mês', 'clientes_sem_vendas', false));
            modalCloseBtn.addEventListener('click', () => modal.classList.add('hidden'));
            clientModalCloseBtn.addEventListener('click', () => clientModal.classList.add('hidden'));
            faturamentoBtn.addEventListener('click', () => { currentProductMetric = 'faturamento'; faturamentoBtn.classList.add('active'); pesoBtn.classList.remove('active'); updateAllVisuals(); });
            pesoBtn.addEventListener('click', () => { currentProductMetric = 'peso'; pesoBtn.classList.add('active'); faturamentoBtn.classList.remove('active'); updateAllVisuals(); });
        }
        
        calculateHistoricalBests();
        populateSupervisors('supervisor-filter', allSalesData);
        populateSupervisors('city-supervisor-filter', allSalesData);
        updateSellerFilter('', vendedorFilterDropdown, vendedorFilterText, selectedSellers, allSalesData);
        updateSellerFilter('', cityVendedorFilterDropdown, cityVendedorFilterText, selectedCitySellers, allSalesData);
        
        updateRedeFilter(mainRedeFilterDropdown, mainComRedeBtnText, selectedMainRedes, allClientsData);
        updateRedeFilter(cityRedeFilterDropdown, cityComRedeBtnText, selectedCityRedes, allClientsData);
        updateRedeFilter(comparisonRedeFilterDropdown, comparisonComRedeBtnText, selectedComparisonRedes, allClientsData);
        
        updateAllComparisonFilters();
        updateStockSupplierFilter(); // NOVO
        updateStockProductFilter(); // NOVO
        
        initializeRedeFilters();
        setupEventListeners();
        updateAllVisuals();
        renderTable(aggregatedOrders);
    </script>

    <script>
        // A SER PREENCHIDO NA PARTE 3
    </script>
</body>
</html>

